[["index.html", "Hosting Shiny Applications for R and Python Everything you wanted to know about hosting Shiny apps Welcome License", " Hosting Shiny Applications for R and Python Everything you wanted to know about hosting Shiny apps Péter Sólymos and Kalvin Eng July 06, 2024 Welcome This is the online version of Hosting Shiny Applications for R and Python, a book currently under development and intended for a 2025 release by CRC Press. Visit the GitHub repository for this site. License This book is licensed to you under Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. The code samples in this book are licensed under the MIT License. "],["foreword.html", "Foreword", " Foreword This is an awesome book! I can recommend it. John Doe, Affiliation "],["preface.html", "Preface Motivation Who Is This Book For? What Will You Learn? What Will You Not Learn? Conventions About the Authors Acknowledgements", " Preface Motivation Shiny is a reactive web application framework used by R and Python users to communicate their results to others. Whether you are just starting out with Shiny, or you are a seasoned programmer, at some point you’ll need to share your app with your colleagues and users. You might decide to send them scripts or deploy the app and share the URL that takes people to your app. The documentation and books about the Shiny ecosystem are phenomenal resources. However, these resources focus on the development of the applications and decidedly cover very little about what to do once the app is deployed. It might surprise you, but there are at least /FIXME: CHECK THIS NUMBER/ 20 hosting options for Shiny. Navigating these options and finding up-to-date advice on choosing one and getting started is not easy or trivial. Information about Shiny hosting is scattered around the Internet and is often incomplete. Recommendations are usually narrowly focused and never really ask such important questions as: Why do you want this app deployed? Who is this app for? What is your budget? The goal of the book is to help you learn about the hosting options and what it takes to host your apps securely. Currently available books also focus on the R aspect of Shiny, which is not surprising given that Shiny for Python is a relatively recent addition to the Shiny ecosystem. Luckily, Shiny for R and Python have very similar deployment and hosting patterns. Therefore, we can cover both in the same book. We think this is important, because with the increasing popularity of Shiny available for R and Python, learning more about the hosting side of the application life-cycle will be a critical need for programming enthusiasts and data science professionals alike. Who Is This Book For? If you are asking the following questions, this book is definitely for you: What Shiny hosting solutions are out there? How do I decide which of these options suits my needs, my budget, and my skill level the best? How can I get started, and where can I get help if I get stuck? If you are not (yet) asking these questions, but want to learn about servers, cloud instances, and containers from the perspective of Shiny apps, this book is still for you. You might be a researchers in academia, government, and at a nonprofit organization who wants to self-host Shiny apps so that you can show your results to your colleagues, your stakeholders, or to the public. You might work at a small agency or a startups and want to securely host apps for your clients and users. Or you might be a data scientists who wants to effectively collaborate with people at the IT and engineering department about Shiny app deployment and hosting. What Will You Learn? The book is structured into four main parts plus appendices. This is what the four main parts will cover: Part I. Getting started – This will give you the fundamentals for the rest of the book, including some background, concepts, and setup instructions. Part II. Shiny Apps – This part deals with everything that happens on your local machine, including developing and organizing Shiny apps, and ways of running the apps locally. Part III. Hosting Shiny Apps – This part describes all the ways how Shiny apps can be hosted on remote machines, like cloud servers. This part is the longest, because there are quite a few hosting options. Part IV. What is next – You’ll find a summary of all the things you might want to do next with your Shiny app, things that might either be too advanced or are harder to describe in a physical book format. The book does not end on the last page. You can find online supplements, including the HTML version of the book and all the code that we present in the book and more on the book’s website https://hostingshiny.dev. What Will You Not Learn? This book is focused on the many different ways of hosting Shiny apps. This topic is at the intersection of R &amp; Python programming, Shiny app development, and DevOps. We assume you are already familiar with either R or Python. If this is not the case, we suggest you start with accessible introductions to R or Python before going further. You don’t need to know both languages, but knowing at least one is definitely needed. We will use example Shiny apps to test and demonstrate the different hosting options, but we are not going to teach you how to master Shiny, how to engineer production-grade apps, and how to make outstanding user interfaces with Shiny. You can find all those in these excellent books: Mastering Shiny (Wickham 2021) Engineering Production-Grade Shiny Apps (Fay et al. 2021) Outstanding User Interfaces with Shiny (Granjon 2022) There is also quite a bit that can be said about servers and cloud infrastructure that we won’t cover in this book. DevOps for Data Science (Gold 2024) gives an accessible overview of DevOps conventions, tools, and practices, and provides pointers for further broadening your knowledge in these areas. Conventions Throughout the book, we will use title case and all caps for software and frameworks, e.g. Shiny, R, Python SSH, HTML, CSS, etc. We will use monospace code font for inline mentions of libraries and extension packages (e.g. shiny, pandas), also for functions and methods (e.g. summary(), pandas.read_csv()), and file names (image.png). Italicized text will be preserved for publication titles (e.g. Mastering Shiny) and for cases when we imitate self talk. FOr example: I feel a little bit lost, what do I do now? We will use bold when highlighting or emphasizing words. URLs when pointing to Internet resources, like websites, will be in normal font (e.g. https://mastering-shiny.org), URLs when mentioning with regards to examples will be in code font (e.g. http://127.0.0.1). We will use angle brackets for variable values that you should replace in your code, e.g. https://&lt;your-domain&gt;. Dot-dot-dot within brackets, [...], will indicate that we trimmed the output to save space by not showing too verbose or repetitive text in the book. We will use backslash (\\) to break up long commands to help readability and to fit on the printed page. We use the h10y as a shorthand for Hosting Shiny, and it means that between the first letter H and the last letter Y there are 10 other letters. You will see the domain h10y.com used to shorten links and to prevent link rot after the print version of the book is out. We will also use h10y in Docker image namespaces to make image tags shorter. About the Authors Péter Sólymos is a senior data scientist with 20 years of experience in wildlife, environmental, and utilities sectors. He holds a PhD in biology, he has authored 70 peer-reviewed publications and several statistical software packages. He is passionate about using statistics and data science to bridge the gap between data and decision making. His focus is on enabling this by helping organizations adopting cloud-native practices into their operations. FIXME: PETER to revise. https://peter.solymos.org Kalvin Eng is a PhD candidate in Computing Science at the University of Alberta with over 15 years of software development experience. His research involves understanding and improving the processes of software engineering. He is passionate about helping organizations develop efficient processes to build software more effectively. FIXME: KALVIN to revise. https://kalvineng.com Acknowledgements We are grateful for Kahlid Lemzouji for continuously finding new reasons to up our game with Shiny hosting. Thanks to Kalob Taulien for helping with our early endeavors with Shiny hosting. Some of the content of this book was developed as part of workshops held by the authors at the Edmonton R User Group (YEGRUG). We are thankful for the Statistical Society of Canada for inviting us to teach the course Delivering applied statistics from concept to production. FIXME: add here more names as needed - The authors would like to thank a whole bunch more people. - Who provided reviews and we know there names. References Fay, Colin, Sébastien Rochette, Vincent Guyader, and Cervan Girard. 2021. Engineering Production-Grade Shiny Apps. Chapman &amp; Hall. https://engineering-shiny.org/. Gold, Alex. 2024. DevOps for Data Science. Chapman &amp; Hall. https://do4ds.com/. Granjon, David. 2022. Outstanding User Interfaces with Shiny. Chapman &amp; Hall. https://unleash-shiny.rinterface.com/. Wickham, Hadley. 2021. Mastering Shiny. O’Reilly Media, Inc. https://mastering-shiny.org/. "],["1-background.html", "Chapter 1 Background 1.1 Data-intensive Apps 1.2 Enter Shiny 1.3 Application Development 1.4 Application Hosting 1.5 The DevOps Cycle 1.6 The Hosting Cycle 1.7 Summary", " Chapter 1 Background As a data professional working with R or Python, you might have a workflow that loads and transforms some data. You might have to explore and visualize this data, run some analyses and summarize your findings in reports. You can send the report, or even the data and reproducible scripts to others. In which case, they will have to be able to load and run you code. Wouldn’t it be easier to deliver your findings as interactive documents or web applications? In this chapter, you’ll see what Shiny can offer when it comes to data-intensive web applications, and you will be familiar with the workflow of developing and operating such web applications. 1.1 Data-intensive Apps Data-intensive applications, or data apps for short, are modern web applications that are centered around operations on data. This is different from traditional websites that focus on providing information for a user. The primary goal of data apps is to make data-intensive operations approachable. For non-technical users, this might mean simplifying a sophisticated/complex task like processing a CSV data file to a PDF report. For technical users, it can offer an intuitive understanding of complex relationships through interactive visualization, or it can help in institutionalizing the workflows that are incorporated in the apps. The steps involved in simplifying data-intensive operations resemble more traditional workflows used by analysts through the command line: Data import (files, databases) Data transformation (extract–transform–load; ETL) Summarizing the data (descriptive statistics) Visualization and exploratory data analysis (EDA) Repeating these steps for different subsets or slices of the data (interactive and reactive) Saving, storing, or exporting these results (files, databases) Because these apps allow users to interact with the data, these apps share some similarities with desktop software applications, like Excel. But unlike desktop applications, data apps are accessed through the browser. This is advantageous as your application is able to run on any device that has a web browser like a desktop, tablet, or phone. There is also a distinction between our definition of data apps and general-purpose analytics tools, like Microsoft PowerBI or Tableau. Such tools are primarily used for exploratory purposes, whereas data apps are custom built and capable of answering questions in lot more depth. This is possible because of all the analytics capabilities of R and Python can be called upon in real time. In other words, data apps can be exploratory and explanatory at the same time. 1.2 Enter Shiny If your analytics workflow is built using R or Python, Shiny is the easiest way to create data science related web applications. Shiny can also power dynamic documents. As advertized by the shiny R package description (Chang et al. 2024): [Shiny] Makes it incredibly easy to build interactive web applications with R. Automatic “reactive” binding between inputs and outputs and extensive prebuilt widgets make it possible to build beautiful, responsive, and powerful applications with minimal effort. In other words, you can turn your data and scripts into a web application with limited web development skills. Shiny lets you to create a web app without knowing HTML, JavaScript and CSS. But more importantly, it will also let you include reactivity, so your users can dynamically explore the results. Reactivity is the most important and distinctive feature of Shiny, compared to similar web application frameworks know mostly in Python. Reactivity responsible for re-executing parts of the code when things change as the result of users interacting with the app. This is possible through reactive bindings between inputs and outputs. The apps are also interactive, which is different from being reactive in the sense that during interactive behaviour, the state of the application stays the same on the backend, changes are only rendered on the client side (i.e. in your browser). Think of popups, hover labels, transitions, and animations. This behavior is usually powered by the front-end JavaScript code. The thirds feature mentioned in the Shiny R package description is responsiveness. It refers to the styling of the rendered web application. Again, client-side JavaScript and CSS code used by the Shiny user interface is responsible for the app responding to various device sizes (desktop, tablet, phone), or viewports (resizing the window). Size responsive systems allow the web page to respond to changes according to well thought-out rules without the interface elements falling apart. 1.3 Application Development Application development begins with an idea of what you would like your app to do. In a first iteration, you will have a proof-of-concept version of the app that will likely have bugs and need more refinement. It might take several iterations of fixing bugs and incorporating feedback from the users until the data app reaches its final form. Even after that, you might have to update the data behind the app, incorporate latest technologies, and provide security updates for the users. You might not make fundamental changes to the app any more, but you are still releasing new versions from time to time. This also means that you might want to test your changes before releasing the new version to your users. App development is usually based on accumulating small changes, continuously testing these changes, and releasing these changes to the users at a pre-determined cadence, depending on the criticality of the changes made to the app. You might not wait too long with a security update. However, new features might get released monthly or yearly. If you are using Shiny, you are participating in application development. Shiny is a web application framework that can help with the application development process. As a framework, it abstracts most of the complicated code needed for user interfaces, leaving you more time to focus on developing data features for your data app. Shiny is integral in simplifying the application development process for data-intensive apps. 1.4 Application Hosting Once you’ve developed your Shiny application, you might be wondering how you can share the application to your colleagues or a wider audience. This is where the concept of application hosting comes in. Hosting an app includes operations required for successfully and securely running the app online, so that the users of the app get access to it without interruption. It starts with deploying the application. What deployment means, is that a person or an automated process moves some files from one computer to another and refreshes the hosting server to display the new version of the app. You might want to monitor the usage of the app, i.e. how many users are active, when and for how long they are using the app. You should also monitor resource usage on the hosting server, for example CPU, memory, and disk space. This kind of visibility into the system and the ability to retrieve system and application level logs will be critical in case something goes wrong. All these require some up-front investment in learning about and setting up the systems that you will host you app on. After the resources spent on app development and the initial setup, operating costs will be determined by the kind of setup and hosting that is required for delivering the value to your users. The user experience also largely depends on the performance of the servers that the apps are running on, because most of the computations happen on the server-side – i.e. on a remote computer or in the cloud. Other requirements that are less important include the client’s machine specifications are less important. Data apps are expected to run on desktops, laptops, tablets, and phones via a web browser. This is good news for app developers because data apps can be written in different programming languages and still can result in a comparable user experience. One might prefer Python or R, others might use JavaScript. The end result will be very similar: a data app running in the browser. This book will help you gain a better understanding of how to host your Shiny applications walking you through different solutions that can best fit your requirements. 1.5 The DevOps Cycle An important part of application development and hosting is DevOps. DevOps is a set of practices and tools that integrates and in most cases automates the work of software development (Dev) and information technology (IT) operations (Ops). The Dev side is concerned with building a better app, while the Ops side is concerned with providing the best infrastructure to run the app on. DevOps therefore refers to the collaboration culture between that people on both sides to make this process as smooth as possible through the use of monitoring and logging to identify and quickly resolve issues. Figure 1.1 shows the of DevOps cycle as it is often visualized, capturing the development and operations that we described in the previous sections. Figure 1.1: The DevOps cycle. DevOps is also often associated with Continuous Integration and Continuous Deployment (CI/CD). CI/CD practices ensure the reliable delivery of frequent code changes. It emphasizes the use of automation to reduce human error. You can view DevOps and CI/CD as two sides of the same coin. CI/CD is pro-active, and tries to eliminate sources of errors through automation. DevOps is a broader framework that codifies reactive practices when we notice deviations from the plan. Figure 1.1 might suggest that DevOps is a never ending cycle, and that changes can only originate from within the cycle. All of those steps are under the control of the development and operations teams. But in reality, we can imagine many factors that can perturb the ideal system from the outside. These would be factors that we cannot of do not want to control. This is when things do not go according to plan. For example, the system being hacked is never a pleasant experience. Paying ransom, or highjacked servers sending spam emails or mining Bitcoin is nobody’s idea of having fun. Or even the biggest cloud provider can experience outages. These are all events that we can prepare for, but cannot control. Other events throwing the DevOps cycle off the plan might be more benign. Having too many users is often considered a good kind of problem. But unexpected surges in usage might lead to unresponsive servers. Adequate monitoring and alerting can prevent these unfortunate events. But at some point, the team might be faced with a decision. How can we support more users? How can we improve user experience by reducing loading time of the apps? Adapting to changing needs and circumstances often leads to changes in the way how the application is hosted. Changes can be incremental, like you need more CPU or memory for the server. Or it can be more drastic, for example moving from a hosting platform to self hosting your own cloud server. The DevOps cycle illustrates how the development and deployment of an application is iterative. Our book presents the hosting of Shiny applications in a similar fashion that we coin as the hosting cycle described in the next section. 1.6 The Hosting Cycle The hosting cycle is inspired by the DevOps cycle. It is meant to illustrate how you hosting your Shiny application might take many iterations. Let’s give an example. You have a Shiny app that you’d like to deploy. You have read the documentation on the Shiny website and now you are thinking: Posit Connect is pricy, Shiny Server has no licensing fee, and both require self hosting on my own server or in the cloud. I don’t know how to do that. So I will go with Shinyapps. It is free to start with, I can deploy my app with a click of a button from my RStudio Desktop. Shinyapps definitely seems like the best option when starting out. It is free for the first five apps (with limited hours of app usage). You host your app in a cloud platform, i.e. on someone else’s server, that is fully managed. This means less headache for you. You sign up to Shinyapps, you click the deploy button in RStudio Desktop, and you app opens up in the browser a few of minutes later. Let’s take a look at Figure 1.2 that illustrates the cycle of evaluating the Shiny hosting options from time to time. In our example above, we assumed that you are new to Shiny hosting. You did some research, you made your choice based on some criteria, e.g. pricing (free) and operational complexity (managed hosting with push button publishing). Now you are at a stage where the option that you picked is working just fine. This could be the end of the story for hosting your Shiny apps. But more often than not, questions will pop into your head as time goes by. I have many active users an I am running out of free app hours on Shinyapps. I want to host more than &gt;5 apps. I want my custom domain with HTTPS. I need better performance, more memory. I need specialized software libraries installed. I need fine grained access control to my apps. Should you upgrade your Shinyapps subscription? Should you set up your own server and try Shiny Server? Should you convince your boss to foot the bill and buy Posit Connect for your team? There could also be other options out there. This is where the contents of this book will help you make a decision. Your answer might depend on many factors, or your needs might evolve over time. Having an understanding of what it takes to go with certain hosting options will provide the foundation for that. Figure 1.2: Shiny hosting cycle. Reading this book and trying some of the examples yourself will help you to build confidence when it comes to evaluating you Shiny hosting needs and options the next time you arrive to a crossroad. 1.7 Summary We outlined a very generic outline for how the need for a data-intensive application might arise, and the reasons why Shiny might be the right tool for that. You might have your own reasons for picking Shiny and you might also have your unique circumstances and needs. But the DevOps principles will likely apply to you too when developing your app. And the hosting related considerations and options outlined in the “hosting cycle” section will also apply to you. That is why we thing that by reading this book, you will be able to make an informed decision regarding your next steps around hosting your Shiny apps. In the next chapter, we will review important concepts that you might already be familiar with or at least heard about those concepts. It is very important to have a working knowledge of these concepts because as you browse the web or read more advanced materials, you will run into these without much explanation. Shiny simplifies web technology for data professionals, but those web technologies sit under the hood of Shiny’s abstraction layer. Hosting directly interfaces with these fundamentals, so understanding those concepts will help you. References Chang, Winston, Joe Cheng, JJ Allaire, Carson Sievert, Barret Schloerke, Yihui Xie, Jeff Allen, Jonathan McPherson, Alan Dipert, and Barbara Borges. 2024. Shiny: Web Application Framework for r. https://CRAN.R-project.org/package=shiny. "],["2-hosting-concepts.html", "Chapter 2 Hosting Concepts 2.1 Domains and Networking 2.2 Website Technologies 2.3 Servers 2.4 Hosting Environments 2.5 Summary", " Chapter 2 Hosting Concepts To better understand this book, you will need to first gain a general understanding about how web applications are hosted. This includes: domains and networking, website technologies, servers, and hosting environments. Imagine accessing a Shiny application on Internet. At a high level, you visit the application by clicking a link or typing a URL in browser. By visiting the application, the browser performs operations related to domains and networking to serve you the application. The application itself is run in the browser with website technologies. The actual data of the application is hosted on a server that has a hosting environment catered to the Shiny application. Users accessing a Shiny application primarily remember only the website link, abstracting them from understanding the concepts needed for the application to run on the Internet. This chapter delves into how Shiny applications are hosted to, using accessing a Shiny application as a motivating example. By the end of this chapter, you should be able to grasp why an aplication mght not be loading, or why it is taking longer than you have anticipated for an application to load. 2.1 Domains and Networking To access a Shiny application, it begins with a URL like: https://analythium.shinyapps.io/covid-19-alberta/. FIXME: Add better URL There is a lot to unpack with this URL. First, there is the protocol which is the https part. Next is the domain which is the analythium.shinyapps.io. Finally, there is the path part which is /covid-19-alberta/. The protocol specifies how data will be transferred to you. If you use https, which is shorthand for “Hypertext Transfer Protocol Secure”, it means that you will transfer data securely with encryption. If you use http (Hypertext Transfer Protocol), it means that data will transfer data without any encryption. The domain specifies where data will be transferred from. It is a reference to an IP address (Internet Protocol address) that identifies a computer (server) that is available on the Internet. The domain lets your computer know which computer to request data from. The path lets you specify what resource you want from the server. Sometimes, you might see a URL like: https://analythium.shinyapps.io:443/covid-19-alberta/ which is different from the previous URL we introduced (note the “:443”). This new part specifies a port. FIXME: Add better URL The port specifies the connection point of a server. There are common ports for different protocols. For example, for “https” it is usually 443. For “http”, it is usually 80. The URL just specifies how a client connects to a server. The actual connection, requires networking between the client and server using TCP/IP (Transmission Control Protocol/Internet Protocol). TCP/IP is a suite of communication protocols to help computers connect with each other with forms a network of computers. In the case of the Shiny application, a client computer would request data from a server computer and the server sends a response with the requested data. This data contains all the necessary information to serve your application. These request/response operations happen everyday on the Internet to provide access to applications like your Bank portal or social media app. 2.2 Website Technologies The data that comes from a server is provided in a raw format that needs to be interpreted by a client. In the case of a Shiny application, the data provided is meant to be interpreted by a web browser that serves a website. A website uses many technologies to interpret which commonly includes: HTML (HyperText Markup Language), CSS (Cascading Style Sheets), and JavaScript. Shiny applications use HTML, CSS, and JavaScript to render a web application. The HTML contains textual information about a website. While the CSS provides styling for a website. The JavaScript enables interactivity for a website by communicating with the Shiny application backend. The Shiny applciation backend runs on either R or Python and renders the data needed to render the application on a web browser. 2.3 Servers A server is a computer that runs indefinitely, and is available to serve content to anybody that requests it. Servers can be costly to run and are often shared with other users. To alleviate any concerns of security and resource sharing a server can be shared through a virtual layer. By using a virtual layer, a virtual private server can be created. This is where a server’s resources can be allocated to be used exclusively by a user. Servers can be offered as either as a IaaS (infrastructure as a service) or PaaS (platform as a service). IaaS requires more configuration and requires some server administration knowledge. While PaaS simplifies configuration by abstracting management to a platform. FIXME: Expand on IaaS and PaaS 2.4 Hosting Environments On servers that are meant to serve web applications, environments are specifically setup to help run web applications. A lot of consideration of security, compatibility, and optimization goes into hosting environments to ensure that a web application runs as intended. In terms of security, you must consider firewalls, how data is transmitted, and who can access your app. These considerations may not be known to the end user of your Shiny application, but it is important for you to be aware of when hosting a Shiny application. In terms of compatibility, virtualization and containers can help make your application run on any platform. Otherwise, you might spend a lot of time installing the right software to run your Shiny application. This also helps make your application scalable by being able to easily deploy on multiple instances of a platform. In terms of optimization, you must consider how to route your traffic to ensure that your app runs smoothly. Many of the times, there might be high demand for your application. This is where multiple instances of your Shiny application might come in handy, where you are able to distribute the requests for your application. FIXME: We will leave pointers to: other chapters other books/websites 2.5 Summary In this chapter, we have covered the basic concepts needed for understanding the subsequent sections. In short, we have explained at a high level what goes into hosting a Shiny application and how it is served over the Internet. In the next chapters, you will learn more details about how hosting a Shiny application including more advanced concepts such as: Creating a virtual environment for your Shiny application with a container Where to host your Shiny Application in the Cloud Considerations for making your Shiny Application production ready "],["3-local-setup.html", "Chapter 3 Local Setup 3.1 Installing Your Developer Tools 3.2 The Command Line 3.3 Source Code Management with Git 3.4 Servers 3.5 Readability on the Command Line 3.6 Summary", " Chapter 3 Local Setup To make your Shiny applications accessible for a wider audience, you must have some tools available locally on your laptop or desktop — sorry, a tablet or a phone are not recommended devices for this. You will become familiar with several tools used to manage your code locally or communicate with remote machines. By the end of this chapter, you should have obtained the knowledge and the local setup of tools to connect to a remote server and run a Shiny app from the command line. 3.1 Installing Your Developer Tools 3.1.1 R R is a programming language designed mainly for statistical computation, but it has been extended with packages to support tasks like developing web apps with Shiny. To begin, you must install the appropriate binary for your operating system available at https://cran.r-project.org/ under the “Download and Install R” section. Next, you should install an integrated development environment or IDE of your choice. One of the most popular ways to develop in R is to use the RStudio Desktop developed by Posit (formerly RStudio). You can download the binary from https://posit.co/download/rstudio-desktop/. Another increasingly popular IDE option for R is Microsoft’s VisualStudio Code, or VS Code for short. You can download the installer from https://code.visualstudio.com/download. It is recommended to use the R extension for VS Code that relies on the languageserver R package (Lai 2023). You can find setup instructions in the REditorSupport/vscode-R GitHub repository. Another useful extension is the Shiny VS Code extension from the VS Code Marketplace or the Open VSX Registry. To install Shiny, you can run the command install.packages(\"shiny\") in the R console. You will need a few other packages too: install.packages(c(&quot;bslib&quot;, &quot;shinylive&quot;, &quot;htmltools&quot;, &quot;rmarkdown&quot;)) FIXME: list other R packages. 3.1.2 Install Python As a scripting language, Python is versatile and can be developed in different environments including text editors and IDEs. The recommended IDE for developing in Shiny with Python is VS Code. To use the IDE for Python, you must ensure that Python can run on your operating system. Operating systems like MacOS and Linux should already have come bundled with a version of Python, but it may be an older version. Therefore, we recommend installing the latest Python version for MacOS and Windows from https://www.python.org/downloads/. For Linux/Unix based operating systems, we recommend installing Python using the command line with the following commands: Install Shiny with pip install shiny. Some of the examples will use Shinylive, you can install it with pip install shinylive. FIXME: CHECK this, how to install Python and pip etc. The Shiny VS Code extension from the VS Code Marketplace or the Open VSX Registry works with R and Python as well. Python itself also has VS Code extensions that can be used. A rathe new IDE option that R and Python users should keep an eye on is Positron by Posit as it promises to be an extensible, polyglot tool for writing code and exploring data. 3.1.3 Web Browser You likely already have a web browser on your local machine. Most people use Chrome, Saferi, Edge, Firefox. 3.1.4 Quarto Quarto is a open-source scientific and technical publishing system by Posit that can include Shiny apps. You can find install instructions at https://quarto.org/docs/get-started/. 3.1.5 Docker Desktop To download and install Docker for your platform of choice, visit the Docker download page and follow the instructions. If you are a Mac OS X user on Apple Silicone (M1 chip and above), you might want to enable virtualization to be able to run and build images for AMD64 architecture. Otherwise the images might have poor performance or fail on other platforms. Go to the Settings in Docker Desktop, and under the General tab check the “Use Virtualization framework” and “Use Rosetta for x86_64/amd64 emulation on Apple Silicon” boxes. 3.2 The Command Line The command line is a text-based user interface to control a computer. Instead of using a mouse, you use your keyboard to type commands to control the computer. This is different than the graphical user interfaces (GUIs) used in modern day operating systems like Windows, Mac OSX, and Ubuntu Desktop Linux. The command line is important for managing your Shiny app deployment on a remote server where there might not be a GUI for you to control the remote server. Depending on your operating system, there are different options for the command line. On Windows, we recommend installing Windows Subsytem Linux in order to use a Linux based command line. This is because some commands that we describe in this book may be incompatible with Windows based command lines like PowerShell (comes preinstalled on Windows) or Git Bash. For Mac OS X, we recommend using the built-in terminal application. You will be able to run the commands that we describe in the book. For Linux-based systems like Ubuntu , you can also use the built-in terminal application. Our book will cover commands using a “*nix based command line”. This means the Windows Subsytem Linux terminal or the built-in terminals with Mac OS X or Ubuntu. The terminal is also available from inside your IDE (RStudio or VS Code), which means that you won’t have to change windows to access it. Now let’s review some of the most common shell commands that we’ll need in the absence of a graphical user interface (GUI). 3.2.1 Navigation Navigating through the command line might seem daunting at first. However, it is quite simple once you memorize 3 key commands involving directories. 3.2.1.1 Current Working Directory To know which directory you are in, you can type the pwd command. This will give you the path of the “working directory” that you are in. 3.2.1.2 Listing Directory The ls command is used to list all files in a directory. This is important to know when you are trying to find a file on the command line. 3.2.1.3 Change Directory The cd command is used to change directories and traverse a computer. For example, you may want to change your working directory to a nested folder of your current working directory. In order to do so, you would type cd in the command line and typing a space after, and then press tab to see the available directories to traverse to. With the correct directory in mind, you can type the directory name after and press enter to change directories. To verify that you are in the new directory, your command line should indicate the current directory that you are in. If you are still unsure, you can use the pwd command to get the path of your current working directory. By running cd .. you can go up one directory. To go up 2 directories, you can run: cd ../... 3.2.2 Editing Files Once you can navigate through the computer with command line. The next important task to know about is editing files with a text editor. There are many popular text editors that usually come bundled with your *nix based command line including: nano, vim, and emacs. Vim and Emacs are much more complex and require more technical knowledge to edit and save files. Therefore, if your are just staring out, we recommend using Nano. Nano is a user-friendly text editor that allows you to edit files from the command line. To begin, you can type nano followed by a space and the name of the file you want to edit, e.g. nano app.R. If the name of the file does not exist, nano will create the file for you when you save it. To navigate through a file with Nano, you can use your arrow keys to move the cursor. You can add text to the file by typing on your keyboard. The instructions for nano are at the bottom of the editor. The ^ stands for the CTRL key and the letter beside it stands for the key you press to run the command. Press the CTRL key together with the letter on the keyboard to execute a command. To save the file, you would press CTRL + O and confirm the prompts with enter. To exit nano, you would press CTRL + X. 3.2.3 File and Directory Operations It is also important to know about how to move, copy, and delete files and directories. Furthermore it is also important to know how to create directories. 3.2.3.1 Making Directories To make a directory you would type mkdir followed by a space and the directory name. To confirm that the directory is created, you can run the ls command and see that the folder has been created. You can even try to navigate to it with the cd command. 3.2.3.2 Moving Files and Directories To move a file or directory, you would simply type mv &lt;path to file you want to move&gt; &lt;destination path&gt;. You can verify that a file or directory has moved with ls &lt;destination path&gt; and you should see that in its new location. 3.2.3.3 Copying Files and Directories Copying files is similar to moving files. To copy a file, you would run cp &lt;path to file you want to copy&gt; &lt;destination path and filename&gt;. To copy a directory, you will need to add the -r flag so that the whole directory is copied “recursively”. The command you would run would be: cp -r &lt;path to directory you want to copy&gt; &lt;destination path and directory name&gt;. You can verify that a file or directory has been copied with ls &lt;destination path&gt; and you should see that in its new location. 3.2.3.4 Deleting Files and Directories To delete files run: rm &lt;path to file you want to delete&gt;. For deleting directories, you will need to add the -r flag so that the whole directory is deleted “recursively”. The command to delete directories is: rm -r &lt;path to directory you want to delete&gt;. You can verify that a file or directory has been removed with ls &lt;path to old file or directory&gt;. There should be an error saying that the file and directory do not exist. 3.2.4 Super User Access At times you may find that you do not have the correct permissions to edit a file or even view a directory. Therefore, you must use super user access to gain the correct permissions for your current user. If you are looking for super user permissions for a single command you can run: sudo &lt;command&gt;. Command in this case can be any command line command including the ones we have described earlier in the chapter like rm. For example, you could run sudo rm test.txt where we are using super user access to delete the test file. You may also find that you need super user permissions for multiple commands. In this case you can start a command line as a super user by running sudo -i and following the prompts. To exit out of the super user command line you can press CTRL + D or run the command logout or exit. 3.3 Source Code Management with Git Source code management is important to keep centralized versions of your Shiny application source code. By centralizing your source code, you can have one source truth of your application code that can be duplicated anywhere. Source code management also helps to save different versions of a file without creating multiple copies of a file. Git is one of the most popular version control systems for software. In this section, we will be describing how to get started with Git. Git comes installed by default on most Mac OS X and Linux machines. On Windows you can install Git from https://git-scm.com/download/. Try git version in the terminal to test if Git is installed properly. 3.3.1 Git Services Git services help host your source code remotely. Two of the most popular Git services are GitHub and GitLab. Both are good choices and the instructions in this section apply to both services. However, we recommend using GitHub as later in the book we describe continuous deployment and continuous integration (CICD) that relies on GitHub Actions. 3.3.2 Git Commands To follow along with the commands, you will first need to sign up for your Git service. Following sign up, you should create an empty repository which will host your source code. In this book, we will outline how to use Git from the command line. There are also graphical user interfaces (GUIs) for git. However, when connecting remotely to a server, a GUI to use the server is unavailable. We recommend that you set your default Git text editor to nano with this command: git config --global core.editor \"nano\". Often the default editor is set to Vim or emacs which is harder to use. 3.3.2.1 Cloning Repositories Once you have created a repository, you can clone it to your computer. To do so, you would run git clone &lt;repository url&gt; and enter the appropriate credentials. For example, you can clone the GitHub repository with one of our Shiny app examples, the Old Faithful example as: git clone https://github.com/h10y/faithful.git If you are cloning a private GitHub repository, you must setup an access token to be used as a password for the git clone command. For private GitLab repositories, you would use the same password to be used as you would sign in on the website, but you can also create an access token. 3.3.2.2 Creating a Commit When you have cloned the repository, you can begin adding file changes via a commit. To begin, you would add or modify files in the repository directory. After you have made changes, you can create a commit using three commands. First, you would run git add . from the root directory of your repository. This command stages your changes for the commit. The . signifies the current directory and all its files and directories in it. Next, you would run git commit -m \"&lt;message for your commit&gt;\" to create a commit with a message. The -m flag indicates that you will have a message for your commit. You must enclose your message within quotation marks. A commit must always have a message. Finally, once you have created your commit, you can push your changes with git push. 3.3.2.3 Pulling Changes You might have multiple copies of your repository on different computers. In such cases, to keep the changes of files and directories in sync, you can run the git pull command. It should be noted that if you make changes in your repository without committing them, you must commit your changes before performing a pull. If you have committed changes and the repository has been updated elsewhere, merge conflicts may arise. To detect which files have conflicts, you can run the git diff --check command which shows the files and line numbers that have conflicts. The conflicts in the files will appear as &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD at the top with the current changes you have under it. This is separated with ======= and the changes that are conflicting under it. The conflicting changes are concluded with &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;branch name&gt;. You must delete the &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD and enclosing &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;branch name&gt;, keeping only the change that you want and running git commit to resolve any conflicts for your repository. 3.3.2.4 Status of Repository To determine what files you changed and are not tracking, you can run the git status command. This command will give you the files you have modified and files that are not yet tracked by git. This command will also tell you how many changes you have locally that haven’t been pushed to the git service yet. 3.3.3 .gitignore Often there are extraneous files that are artifacts of running your Shiny application or contain sensitive information, like passwords or access tokens, and do not need to be committed. To ignore these files, you can create a .gitignore file in the root of your repository. To generate a .gitignore file, you can visit gitignore.io which will generate a file with the files and directories to ignore for an operating system, programming language, or tool. We recommend selecting: linux, macOS, windows, R, and Python as a base .gitignore. 3.3.4 Branching Branching is a more advanced concept in Git that is useful when you have multiple people working on the same files. In this subsection, we will briefly touch on the basics of git branching. A branch is a copy of a repository that you can work on and make changes for a specific feature. Once that feature has been completed you can merge it back to your main branch. This allows multiple people to work on the same codebase. To see the branches that exist in your repository, run the git branch command. To create a branch in your repository, run the git checkout -b &lt;branch name&gt; command. It should be noted that when you first try to push your new branch with git push, you will be unsuccessful since the remote repository has no idea of the branch. Therefore you must run git push --set-upstream origin &lt;branch name&gt;. Do not worry if you cannot remember this command! Git will give you a reminder of the command to run to push a new branch. To switch branches, run the git checkout &lt;branch name&gt; command. To merge the changes of one branch to your current branch, run the git merge &lt;branch name&gt; command. There is an option to review merges on GitHub and GitLab. On GitHub, you would open a pull request. On GitLab, you would open a merge request. Both of these options are not part of Git itself, but offered by Git services so that code development can be more collaborative. A pull request or merge request, allows you to preview the merged changes, comment on specific lines of the changes, and fix any conflicts before merging. Often, you can use Git-based workflows to make changes to your Shiny application codebase. The GitHub workflow is a lightweight workflow that leverages pull requests for collaborative development. Developers create feature branches from the main branch, make changes, and then open pull requests to propose these changes for review. Once reviewed and approved, the changes are merged into the main branch. 3.4 Servers Your Shiny App deployment is likely going to live on a remote computer that is always running, aptly named a “server”. In this section, we will be explaining how to connect remotely to servers via SSH from the command line. Servers running remotely often do not contain a graphical user interface, and therefore it is recommended to become familiar with the command line. Once connected, you can run the command line commands explained in the previous sections of this chapter. The commands in the following subsections require the setup of a server. We outline how to do so in Part IV. However, you can also just read along to familiarize yourself with the basic concepts of using a remote server. 3.4.1 Secure Shell (SSH) The secure shell protocol (SSH) is used to securely connect with a remote computer. The connection works via public key cryptography. This means that a public key lives on the server and you have a private key on your local machine. The private key on your local machine matches with the public key on the remote machine to verify your identity. There are two common ways to authenticate with SSH: using a password, or using a private/public key pair. It is recommended to use the private/public key pair method as it is much harder to guess a private key compared to a password. 3.4.1.1 Password Authentication To authenticate with a password, you can run this command: ssh &lt;user name&gt;@&lt;server ip address&gt;. When you authenticate with a password, a private/public key pair is automatically generated for you. However, this method is less secure because a password is easier to guess compared to a randomly generated key file. 3.4.1.2 Key-based Authentication To authenticate with a key file, you can run this command: ssh -i &lt;location of key file&gt; &lt;user name&gt;@&lt;server ip address&gt;. By running this command, the remote computer can verify that the user logging in with the public key that is stored on the remote computer. We outline how to generate a key in Part IV. 3.5 Readability on the Command Line Sometimes commands are too long or it would help reading them if we could put the parts on multiple lines without “hitting Enter” (executing) too early. This is where the backslash (\\) comes in. We can use the \\ to write multi-line commands. For example these two dummy examples are identical: ssh -i ~/.ssh/id_rsa root@123.456.78.90 ssh -i ~/.ssh/id_rsa \\ root@123.456.78.90 3.6 Summary You have all the knowledge and tools installed on your local computer to effectively develop your Shiny app and to interact with remote servers and online services. Before we review the different ways of developing and hosting your Shiny app, we quickly introduce a few example apps. We will use these apps to demonstrate the steps for the hosting options. References Lai, Randy. 2023. Languageserver: Language Server Protocol. https://CRAN.R-project.org/package=languageserver. "],["4-examples.html", "Chapter 4 Examples 4.1 Old Faithful 4.2 Bananas 4.3 Load Balancing Test 4.4 Summary", " Chapter 4 Examples Shiny apps come in many different shapes and form. We will not be able to represent this vast diversity, but instead we wanted some apps that can be used to showcase common patterns, and that can also fit onto the pages of a printed book reasonably well. We will use 3 Shiny apps as examples, all 3 are implemented in both R and Python: faithful: a “Hello Shiny!” app displaying the Old Faithful geyser waiting times data as a histogram with a slider that allows to adjust the number of bins used in the histogram — this app demonstrates the very basics of of interactivity, and it is very short. bananas: an app that classifies the ripeness of banana fruits based on the color composition (green, yellow, brown) — this app demonstrates a more complex use case with dependencies, and the app also relies on a machine learning model, thus it better reflects real world use cases. lbtest: an app to test load balancing when scaling Shiny apps to multiple instances. Let’s learn about the example apps. 4.1 Old Faithful This is the classic “Hello Shiny!” app that you can see in R by trying shiny::runExample(\"01_hello\"). The app displays the Old Faithful geyser waiting times data as a histogram with a slider that allows to adjust the number of bins used in the histogram (Fig. 4.1). The R version of the app was originally written by the Shiny package authors (Chang et al. 2024). The “Hello Shiny!” in R has no dependencies other than shiny. The Old Faithful app in Python has more requirements besides shiny, because the Python standard library does not have the geyser data readily available, and you need e.g. matplotlib (Hunter 2007) for the histogram. We wrote the Python version as a mirror translation of the R version, so that you can see the similarities and the differences. Figure 4.1: The faithful example Shiny app. In R, the data set datasets::faithful (R Core Team 2024) contains waiting time between eruptions and the duration of the eruption for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA. We got the Python data set from the Seaborn library seaborn.load_dataset(\"geyser\") (Waskom 2021). The source code for the different builds of the Old Faithful Shiny app is at https://github.com/h10y/faithful. You can download the GitHub repository az a zip file from GitHub, or clone the repository with git clone https://github.com/h10y/faithful.git. 4.2 Bananas The bananas app was born out of a “stuck-in-the-house” COVID-19 project when one of the authors bought some green bananas at the store and took daily photographs of each fruit. Later, the data set was used as part of workshops. The motivation for the app is that it follows workflow that is fairly common in all kinds of data science projects: Have a question to answer: Is my banana ripe? Collect data: Go to the store, buy bananas, set up a ring light and take pictures every day over 3 weeks. Compile the training data: Classify colour pixels and calculate the relative proportions, score pictures according to ripeness status. Run exploratory data analysis: Let’s explore and visualize the data set. Train a classification model: Estimate the probability that the banana ripeness given colour composition. Build a “scoring engine”: Given some colour inputs for a new fruit, tell me the probability that the banana is ripe. Build a user interface: Let a non technical user to do the data exploration and classification as part of a web application. 4.2.1 The Bananas Data Set The data set tracks the ripening colour composition of banana fruits daily over a 3-week period. The full data set can be found in the GitHub repository and R package bananas (install.packages(\"bananas\", repos = \"https://psolymos.r-universe.dev\")). The subset used in the book and the Shiny app constitutes the 6 fruits that were kept at room temperature. The table has the following fields: fruit: the identifier of the fruit, day: number between 0 and 20, the number of days since the first set of photographs, ripeness: the ripeness class of the fruit based in Peter’s personal judgement (Under, Ripe, Very, Over), green, yellow, brown: colour composition, these 3 values add up to 1 (100%). The colour composition was determined based on colour mapping the pixel values of the banana fruits and converting the pixel based 2-dimensional area to proportions. The colour composition was determined based on colour mapping the pixel values of the banana fruits and converting the pixel based 2-dimensional area to proportions. The following summary presents the ripeness (U = Under, R = Ripe, V = Very, O = Over) and the percentage values of green, yellow, brown colours. Figure 4.2 shows the change in colour composition over the 3 weeks of the experiment. You can see that the proportion of green colour went down, parallel to that the yellow colour proportion peaked around day 5. Yellow started decreasing after that while the proportion of brown started increasing. We can also present the same information according to the ripeness classes (Fig. 4.3). You can see that the under-ripe class is characterized by high green proportion and the absence of brown. The ripe class is characterized by the highest proportion of yellow. Very ripe bananas have higher proportion of brown while yellow colour is still the most common. Over ripe bananas are mostly brown. Figure 4.2: Colour composition of the bananas over time. Figure 4.3: Colour composition of the bananas by ripeness class. 4.2.2 Model Training We chose Support Vector Machines (SVM) to model a multi-level response variable (under, ripe, very, over) as a function of the green, yellow, and brown colours. We used the e1071 package (Meyer et al. 2023) in R, and the SVM model’s prediction accuracy was 90.8%. We saved the trained model object as an R binary .rds file: library(e1071) # Read the bananas data x &lt;- read.csv(&quot;bananas.csv&quot;) x$ripeness &lt;- factor(x$ripeness, c(&quot;Under&quot;, &quot;Ripe&quot;, &quot;Very&quot;, &quot;Over&quot;)) # Multinomial classification with Support Vector Machines m &lt;- svm(ripeness ~ green + yellow + brown, data = x, probability = TRUE ) # Two-way table to test prediction accuracy table(x$ripeness, predict(m)) sum(diag(table(x$ripeness, predict(m)))) / nrow(x) # Predict ripeness class predict(m, data.frame(green = 1, yellow = 0, brown = 0), probability = TRUE) predict(m, data.frame(green = 0, yellow = 1, brown = 0), probability = TRUE) predict(m, data.frame(green = 0, yellow = 0, brown = 1), probability = TRUE) predict(m, data.frame(green = 0.1, yellow = 0.2, brown = 0.7), probability = TRUE) # Save the model object saveRDS(m, &quot;bananas-svm.rds&quot;) We can fit a similar SVM model in Python using scikit-learn (sklearn) (Pedregosa et al. 2011): import pandas as pd from joblib import dump from sklearn import svm # Global x = pd.read_csv(&#39;bananas.csv&#39;) # Train SVM x.loc[x.ripeness == &#39;Under&#39;, &#39;target&#39;] = 0 x.loc[x.ripeness == &#39;Ripe&#39;, &#39;target&#39;] = 1 x.loc[x.ripeness == &#39;Very&#39;, &#39;target&#39;] = 2 x.loc[x.ripeness == &#39;Over&#39;, &#39;target&#39;] = 3 data_X = x[[&#39;green&#39;, &#39;yellow&#39;, &#39;brown&#39;]].to_numpy() data_y = x.target.values svm_model = svm.SVC(probability = True) svm_model.fit(data_X, data_y) #&#39; Predict ripeness class svm_model.predict_proba([[1, 0, 0]]) svm_model.predict_proba([[0, 1, 0]]) svm_model.predict_proba([[0, 0, 1]]) svm_model.predict_proba([[0.1, 0.2, 0.7]]) # Write model object to file dump(svm_model, &#39;bananas-svm.joblib&#39;) 4.2.3 The Shiny App The Shiny app consists of a ternary plot showing the daily colour composition of each banana fruit, alongside the new point to be classified (in red), as shown in Figure 4.4. The three numeric inputs on the left hand side of the plot control the position of the red dot. The classification results based on these inputs are shown on the right hand side of the ternary plot. You can see probabilities of under-ripe, ripe, very ripe, and over-ripe classes, and the class with highest probability is assigned as a label. Figure 4.4: The bananas example Shiny app. The source code for the different builds of the Bananas Shiny app is at https://github.com/h10y/bananas. You can download the GitHub repository az a zip file from GitHub, or clone the repository with git clone https://github.com/h10y/bananas.git. 4.3 Load Balancing Test Shiny apps can run multiple sessions in the same app instance. A common problem when scaling the number of replicas for shiny apps is that traffic might not be sent to the same session and thus the app might randomly fail. This app is used to determine if the HTTP requests made by the client are correctly routed back to the same R or Python process for the session. Both the Python and the R version of the app registers a dynamic route for the client to try to connect to. The JavaScript code on the client side will repeatedly hit the dynamic route. The server will send a 200 OK status code only if the client reached the correct Shiny session, where it originally came from (Fig. 4.5). Figure 4.5: The lbtest example Shiny app. The original Python app was written by Joe Cheng and is from the rstudio/py-shiny GitHub repository. We wrote the R version to mirror the Python version. This app will be useful when the deployment includes load balancing between multiple replicas. For such deployments, session affinity (or sticky sessions) needs to be available. This app can be used to test such setups. If the test fails, it will stop before the counter reaches 100 and will say Failure! If the app succeeds 100 times, you’ll see Test complete. The app is not useful for testing a single instance deployment, or with Shinylive, because these setups won’t fail, but you can still try it. The source code for the different builds of the load balancing test Shiny app is at https://github.com/h10y/lbtest. You can download the GitHub repository az a zip file from GitHub, or clone the repository with git clone https://github.com/h10y/lbtest.git. 4.4 Summary This is the end of Part I. We covered all the fundamentals that the rest of the book builds upon. In the next part, we’ll cover all the technical details of Shiny hosting that happens on your local machine. We recommend getting the example repositories mentioned in this chapter available on your computer. This way you will be able to follow all the examples from the following chapters and won’t have to copy paste the text from the book to files. Visit the GitHub organization h10y which stands for hostingshiny (there are 10 letters between the first h and the last y): https://github.com/h10y. References Chang, Winston, Joe Cheng, JJ Allaire, Carson Sievert, Barret Schloerke, Yihui Xie, Jeff Allen, Jonathan McPherson, Alan Dipert, and Barbara Borges. 2024. Shiny: Web Application Framework for r. https://CRAN.R-project.org/package=shiny. Hunter, J. D. 2007. “Matplotlib: A 2D Graphics Environment.” Computing in Science &amp; Engineering 9 (3): 90–95. https://doi.org/10.1109/MCSE.2007.55. Meyer, David, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel, and Friedrich Leisch. 2023. E1071: Misc Functions of the Department of Statistics, Probability Theory Group (Formerly: E1071), TU Wien. https://CRAN.R-project.org/package=e1071. Pedregosa, F., G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, et al. 2011. “Scikit-Learn: Machine Learning in Python.” Journal of Machine Learning Research 12: 2825–30. R Core Team. 2024. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Waskom, Michael L. 2021. “Seaborn: Statistical Data Visualization.” Journal of Open Source Software 6 (60): 3021. https://doi.org/10.21105/joss.03021. "],["5-developing-shiny-apps.html", "Chapter 5 Developing Shiny Apps 5.1 Creating a Shiny App 5.2 Organizing Shiny Apps 5.3 Running Shiny Apps Locally 5.4 Sharing the Shiny App Code 5.5 Summary", " Chapter 5 Developing Shiny Apps Shiny apps can be written in two languages, R and Python. These 2 programming languages are commonly used for data analysis. R is an interpreted computer language for statistical computing and graphics. Likewise, Python is an interpreted general programming language that is often used for data science. Both R and Python run on a wide variety of operating systems including Windows, MacOS, and Linux. In this first chapter, we will cover getting started with developing in Shiny using R and Python environments. We discuss the tools commonly used for these programming languages and provide instructions on how to run our example Shiny application projects in an integrated development environment (IDE). Then we’ll review some of the easiest ways of sharing and deploying Shiny apps. 5.1 Creating a Shiny App A Shiny app is made up of the user interface (UI) and the server function. The UI and the server can be written in pure R or Python, but it can also incorporate JavaScript, CSS, or HTML code. The app is served to the client (app user) through a host (Internet Protocol or IP address) and port number. The server then keeps a websocket connection open to receive requests. The Shiny session behind the app will make sure this request translates into the desired interactivity and sends back the response, usually an updated object, like a plot or a table (Fig. 5.1). Figure 5.1: Simplified Shiny app architecture. The Old Faithful (faithful) app is a relatively simple example that is concise enough to demonstrate the structure of Shiny apps with the basics of reactivity. It draws a histogram based on the Old Faithful geyser waiting times. The number of bins in the histogram can be changed by the user with a slider. The source code for the different builds of the Old Faithful Shiny app is at https://github.com/h10y/faithful. You can download the GitHub repository az a zip file from GitHub, or clone the repository with git clone https://github.com/h10y/faithful.git. To run this app in R, create a folder called r-shiny with a new file called app.R inside the folder. Put this inside the file: # r-shiny/app.R library(shiny) x &lt;- faithful$waiting app_ui &lt;- fixedPage( title = &quot;Old Faithful&quot;, h2(&quot;Old Faithful&quot;), plotOutput(outputId = &quot;histogram&quot;), sliderInput( inputId = &quot;n&quot;, label = &quot;Number of bins:&quot;, min = 1, max = 50, value = 25, ticks = TRUE ) ) server &lt;- function(input, output, session) { output$histogram &lt;- renderPlot( alt = &quot;Histogram of waiting times&quot;, { hist( x, breaks = seq(min(x), max(x), length.out = input$n + 1 ), freq = TRUE, col = &quot;#BB74DB&quot;, border = &quot;white&quot;, main = &quot;Histogram of waiting times&quot;, xlab = &quot;Waiting time to next eruption [mins]&quot;, ylab = &quot;Frequency&quot; ) box() } ) } shinyApp(ui = app_ui, server = server) For the Python version, create a new file called app.py inside the py-shiny folder and put this inside the file: # py-shiny/app.py import seaborn as sns import matplotlib.pyplot as plt from shiny import App, render, ui faithful = sns.load_dataset(&quot;geyser&quot;) x = faithful.waiting app_ui = ui.page_fixed( ui.panel_title(&quot;Old Faithful&quot;), ui.output_plot(id = &quot;histogram&quot;), ui.input_slider( id=&quot;n&quot;, label=&quot;Number of bins:&quot;, min=1, max=50, value=25, ticks=True ), ) def server(input, output, session): @output @render.plot(alt=&quot;Histogram of waiting times&quot;) def histogram(): plt.hist( x, bins = input.n(), density=False, color=&quot;#BB74DB&quot;, edgecolor=&quot;white&quot;) plt.title(&quot;Histogram of waiting times&quot;) plt.xlabel(&quot;Waiting time to next eruption [mins]&quot;) plt.ylabel(&quot;Frequency&quot;) app = App(ui = app_ui, server = server) Besides Shiny, you’ll need to have the seaborn and matplotlib libraries installed for the geyser data set and the histogram. R has these functions as part of the base distribution, so no additional installation is needed. Install Python dependencies from the requirements.txt file with pip install -r py-shiny/requirements.txt. Here are the contents of the requirements.txt file: # py-shiny/requirements.txt shiny&gt;=0.10.2 matplotlib seaborn You have probably noticed the similarities between the R and Python versions. Both started with loading/importing libraries and defining a globally available that contained the Old Faithful geyser waiting times. The files then defined the user interface (app_ui) and the server function. At the end, we defined the Shiny app as shinyApp(ui = app_ui, server = server) and App(ui = app_ui, server = server). Now let us explore the user interface and the server function. 5.1.1 The User Interface The user interface (UI) object controls the layout and appearance of the Shiny app. The UI in R is defined as and object called app_ui: app_ui &lt;- fixedPage( title = &quot;Old Faithful&quot;, h2(&quot;Old Faithful&quot;), plotOutput(outputId = &quot;histogram&quot;), sliderInput( inputId = &quot;n&quot;, label = &quot;Number of bins:&quot;, min = 1, max = 50, value = 25, ticks = TRUE ) ) The fixedPage() function renders the main Shiny interface, a plot output is nested inside of it alongside the range slider input. The slider with the ID \"n\" controls the number of bins in the histogram (ranging between 1 and 50, initial value set to 25). The plot with ID \"histogram\" will show the distribution of the waiting times. If we print the app_ui object, we get the following (slightly edited) HTML output where you can see how the attributes from the R code translate to arguments in the HTML version: &lt;div class=&quot;container&quot;&gt; &lt;h2&gt; Old Faithful &lt;/h2&gt; &lt;div id=&quot;histogram&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group shiny-input-container&quot;&gt; &lt;label class=&quot;control-label&quot; id=&quot;n-label&quot; for=&quot;n&quot;&gt; Number of bins: &lt;/label&gt; &lt;input class=&quot;js-range-slider&quot; id=&quot;n&quot; data-min=&quot;1&quot; data-max=&quot;50&quot; data-from=&quot;25&quot; data-step=&quot;1&quot; data-grid=&quot;true&quot;/&gt; &lt;/div&gt; &lt;/div&gt; You can see the container, and the plot and the slider nested inside. This is going to be added to the body of the HTML page rendered by Shiny. The final HTML page will also contain all the JavaScript and CSS dependencies required to make the app interactive and styled properly. The Python UI uses the ui object imported from shiny. The setup is very similar to the R setup, but naming conventions are slightly different (fixedPage vs. page_fixed, plotOutput vs. output_plot and sliderInput vs. input_slider). app_ui = ui.page_fixed( ui.panel_title(&quot;Old Faithful&quot;), ui.output_plot(id = &quot;histogram&quot;), ui.input_slider( id=&quot;n&quot;, label=&quot;Number of bins:&quot;, min=1, max=50, value=25, ticks=True ), ) Printing the app_ui in Python gives the following (slightly edited) HTML output: &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h2&gt; Old Faithful &lt;/h2&gt; &lt;div id=&quot;histogram&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group shiny-input-container&quot;&gt; &lt;label class=&quot;control-label&quot; id=&quot;n-label&quot; for=&quot;n&quot;&gt; Number of bins: &lt;/label&gt; &lt;input class=&quot;js-range-slider&quot; id=&quot;n&quot; data-min=&quot;1&quot; data-max=&quot;50&quot; data-from=&quot;25&quot; data-step=&quot;1&quot; data-grid=&quot;true&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; The only difference relative to the R output is that you can see the &lt;html&gt;, &lt;head&gt; and &lt;body&gt; tags. Shiny will inject elements into the HTML head later. 5.1.2 The Server Function The server function contains the instructions for the reactivity needed for the Shiny app. The server function takes two arguments: input and output (sometimes also session). These reactive objects are created by Shiny and passed to the server function. input is used to pass the control values, in this case, input$n, the number of histogram bins: server &lt;- function(input, output, session) { output$histogram &lt;- renderPlot( alt = &quot;Histogram of waiting times&quot;, { hist( x, breaks = seq(min(x), max(x), length.out = input$n + 1 ), freq = TRUE, col = &quot;#BB74DB&quot;, border = &quot;white&quot;, main = &quot;Histogram of waiting times&quot;, xlab = &quot;Waiting time to next eruption [mins]&quot;, ylab = &quot;Frequency&quot; ) box() } ) } The output object contains the reactive output objects, in our case the rendered plot. input and output together describe the state of the app. Changes in input (input$n here) will invalidate reactive objects that reference these reactive dependencies and cause the relevant render functions (renderPlot() here) to re-execute. We can see some differences in the Python version. Shiny for Python uses decorators (e.g. @output) instead of render functions and inputs are invoked as input.n(). (See the Framework Comparisons section of the Shiny for Python documentation for a detailed overview of R vs. Python similarities and differences.) FIXME: KALVIN please explain here the @output part etc. def server(input, output, session): @output @render.plot(alt=&quot;Histogram of waiting times&quot;) def histogram(): plt.hist( x, bins = input.n(), density=False, color=&quot;#BB74DB&quot;, edgecolor=&quot;white&quot;) plt.title(&quot;Histogram of waiting times&quot;) plt.xlabel(&quot;Waiting time to next eruption [mins]&quot;) plt.ylabel(&quot;Frequency&quot;) The server function is called once for each Shiny session. A new session with a new websocket connection is created every time a web browser connects to the Shiny application. 5.1.3 Shiny Express Python for Shiny has two different syntax options, Shiny Core that you saw in the previous sections, and Shiny Express. Shiny Core drew inspiration from the original Shiny for R framework, but is not a literal port of Shiny for R. Shiny Expressed was introduced quite recently, and is focused on making it easier for beginners to use Shiny, and might feel more natural to Python users. Shiny Core offers the separation between the UI and the server components, making it easier to organize code for larger Shiny apps. The server function declaration also helps separating code that should only run at startup vs. for the sessions. In Shiny Express, all of the code in the app file is executed for each session. There is only one Shiny syntax option in R. 5.2 Organizing Shiny Apps The previously presented faithful app is organized as a single file. The file contained all the globally scoped declarations at the top, the definition of the UI object and the server function, and ended with the Shiny app object. As Shiny apps grow from demo examples to full on data science projects, the increased complexity will necessitate the organization of the code. You can organize the code into multiple files, or even as a package. Let’s see the most common patterns. 5.2.1 Single file When Shiny is organized in a single file, the convention is to name it app.R. This way your IDE (RStudio or VS Code) will recognize that it is a Shiny app. Apart from this convenience, the file can be named anything, e.g. faithful_app.R. The single file follows the following structure: # Load libraries library(shiny) # Define global variables x &lt;- [...] # Define the UI app_ui &lt;- [...] # Define the server server &lt;- function(input, output, session) { [...] } # Assemble the Shiny app shinyApp(ui = app_ui, server = server) At the end of the file, we define the Shiny app using shinyApp(). To run the app in R, we either have to source the app.R or provide the file name as an argument to the runApp() function, e.g. runApp(\"&lt;app-directory&gt;/app.R\"). The Python version takes a very similar form as a single file, usually named as app.py. # Load libraries from shiny import App, render, ui [...] # Define global variables x = [...] # Define the UI app_ui = [...] # Define the server def server(input, output, session): [...] # Assemble the Shiny app app = App(ui = app_ui, server = server) You can run the Python Shiny app in your IDE or by using the shiny run command in the terminal, shiny run --reload --launch-browser &lt;app-directory&gt;/app.py. This will launch the app in the browser and the server will watch for changes in the app source code and rerender. The libraries and global variables will be accessible for all the Shiny sessions by sourcing the app file when you start the Shiny app. Variables defined inside the server functions will be defined for each session. This way, one user’s changes of the slider won’t affect the other user’s experience. However, if one user changes the globally defined variables (i.e. using the &lt;&lt;- assignment operator), those changes will be visible in every user’s session. 5.2.2 Multiple Files If your app is a bit more complex, you might have multiple files in the same directory. By convention, the directory contains at least a server.R file and ui.R file. Sometimes, there is a third file called global.R. The global.R file is used to load packages, data sets, set variables, or define functions that are available globally. The directory can also have a www folder inside that can store assets (files, images, icons). Another folder is called R that can hold R scripts that are sourced before the app starts up. This is usually the place to put helper functions and Shiny modules, which are also functions. If you prefer, you can use the source() function to explicitly source files as part of the global.R script. Just don’t put these files in the R folder to avoid sourcing them twice. The bananas app is organized into multiple files. Here is how the folder structure looks like for the R version of the app: bananas/r-shiny ├── R │ └── functions.R ├── bananas-svm.rds ├── bananas.csv ├── dependencies.json ├── global.R ├── server.R └── ui.R The global.R file looks like this: # bananas/r-shiny/global.R library(shiny) library(plotly) library(e1071) x &lt;- read.csv(&quot;bananas.csv&quot;) x$ripeness &lt;- factor(x$ripeness, c(&quot;Under&quot;, &quot;Ripe&quot;, &quot;Very&quot;, &quot;Over&quot;)) m &lt;- readRDS(&quot;bananas-svm.rds&quot;) Apart from loading libraries, we read in a CSV file, set factor levels so that those print in a meaningful order instead of alphabetical. Finally, we load the model we trained earlier. There is also the file functions.R in the R folder that gets source automatically. It is important to note, that functions defined inside the files of the R folder, or anything the you source() (e.g. source(\"R/functions.R\")) will be added to the global environment. If you want a sourced file to have local scope, you can include that for example inside your server function as source(\"functions.R\", local = TRUE). To run this app, you can click the Run App button the the IDE or use runApp(\"&lt;app-directory&gt;\"). As long as the directory contains the server.R and the ui.R files. The choice between single vs. multiple files comes down to personal preference and the complexity of the Shiny app. You might start with a single file, but as the file gets larger, you might decide to save the pieces into their own files. However, keeping Shiny apps in their own folder is generally a good idea irrespective of having single or multiple files in the folder. This way, changing your mind later won’t affect how you run the app. You can just use the same runApp(\"&lt;app-directory&gt;\") command, if you follow these basic naming conventions. We can also split the Python version of the bananas app into multiple files. bananas/py-shiny ├── app.py ├── bananas-svm.joblib ├── bananas.csv ├── functions.py └── requirements.txt Sourcing files in Python works slight differently in Python. It is not like adding scripts inline as you saw for R. But rather it follows the same namespace pattern as importing from libraries. These are the first few lines of the app.py file: # bananas/py-shiny/app.py from shiny import App, render, reactive, ui from functions import * [...] We import objects from shiny, then import everything from the functions.py file. We define plotting helper functions in this file. But we also have to import libraries used inside functions.py within the scope of that file: FIXME: KALVIN please clarify this to be clear for python users # bananas/py-shiny/app.py import plotly.graph_objects as go [...] To run a Python Shiny app that is in multiple files, you still need to specify the file that has the Shiny app object defined that you want to run, shiny run &lt;app-directory&gt;/app.py. Or if the file is called app.py and the app object is called app, you can use shiny run from the current working directory. As Shiny for Python apps become more widespread in the future, we will see many different patterns emerge with best practices for organizing files. 5.2.3 Shiny App with Nested Files Structure Your app can grow more complex over time, and you might find that the of the multiple-file structure described above to be limiting. You might have Shiny modules inside Shiny modules. Such a setup might lend itself to a hierarchical file structure. If this is the case, you can use the Rhino Shiny framework and the rhino R package (Żyła et al. 2024). This Shiny framework was inspired by importing and scoping conventions of the Python and JavaScript languages. Rhino enforces strong conventions using a nested file structure and modularized R code. Rhino also uses the box package (Rudolph 2024) that defines a hierarchical and composable module system for R. Here is the directory structure for the Rhino version of the faithful app: faithful/r-rhino ├── app │ ├── main.R │ └── static │ └── favicon.ico ├── app.R ├── config.yml ├── dependencies.R └── rhino.yml The app/static folder serves a similar purpose to the www folder. The R code itself is ins the app.R folder, specifically the app/main.R file. You can see how the import statement is structured at the beginning, and how a Shiny module is used for the ui and server: box::use( shiny[fixedPage, moduleServer, NS, plotOutput, sliderInput, renderPlot], graphics[hist, box], datasets[faithful], ) x &lt;- faithful$waiting #&#39; @export ui &lt;- function(id) { ns &lt;- NS(id) fixedPage( [...] ) } #&#39; @export server &lt;- function(id) { moduleServer(id, function(input, output, session) { output$histogram &lt;- renderPlot( [...] ) }) } To run this app, you can call shiny::runApp(), the app.R file contains a single line calling rhino::app() which creates the Shiny app object. The developers of the framework also released a very similar Python implementation called Tapyr. 5.2.4 Programmatic Cases In R, if you want to run the Shiny app as part of another function, you can supply a list with ui and server components (i.e. runApp(list(ui = ui, server = server))) or a Shiny app object created by the shinyApp() function (i.e. runApp(shinyApp(ui, server))). Note that when shinyApp() is used at the R console, the Shiny app object is automatically passed to the print() function, or more specifically, to the shiny:::print.shiny.appobj function, which runs the app with runApp(). If shinyApp() is called in the middle of a function, the value will not be passed to the print method and the app will not be run. That is why you have to run the app using runApp(). For example, we can write the following function where app_ui and server are defined above as part of the single-file faithful Shiny app. The ... passes possible other arguments to runApp such as the host or port. run_app &lt;- function(...) { runApp( shinyApp( ui = app_ui, server = server ), ... ) } Start the app by typing run_app() into the console. 5.2.5 Shiny App as an R Package Extension packages are the fundamental building blocks of the R ecosystem. Apps can be hosted on the Comprehensive R Archive Network (CRAN), on GitHub, etc. The tooling around R packages makes checking and testing these packages easy. If you have R installed, you can run R CMD check &lt;package-name&gt; to test your package that might include a tests folder with unit tests. Including Shiny apps in R packages is quite commonplace nowadays. These apps might aid data visualization, or simplify calculations for not-so-technical users. Sometimes the Shiny app is not the main feature of a package, but rather it is more like an extension or a demo. In such cases, you might decide to put the Shiny app into the inst folder of the package. This will make the app available after installation, but the app’s code will skip any checks. A consequence is that some dependencies of the app might not be available, because that is not verified during standard checks. At the time of installation, the contents of the inst folder will be copied to the package’s root folder. Therefore, such an app can be started as e.g.  shiny::runApp(system.file(\"app\", package = \"faithful\")). This means that there is a package called faithful, and in the inst/app folder you can find the Shiny app. FIXME: add here link to the r-package version of the faithful example # faithful ├── DESCRIPTION ├── LICENSE ├── NAMESPACE ├── R │ └── run_app.R ├── inst │ └── app │ ├── global.R │ ├── server.R │ ├── ui.R │ └── www │ └── favicon.ico └── man └── run_app.Rd We will not teach you how to write an R package. For that, see R’s official documentation about Writing R Extensions, or Hadley and Bryan (2023). The most important parts of the R package are the functions inside the R folder and the DESCRIPTION file, that describes the dependencies of the package: Package: faithful Version: 0.0.1 Title: Old Faithful Shiny App Author: Peter Solymos Maintainer: Peter Solymos &lt;[...]&gt; Description: Old Faithful Shiny app. Imports: shiny License: MIT + file LICENSE Encoding: UTF-8 RoxygenNote: 7.3.1 The inst folder contains the Shiny app, the man folder has the help page for our run_app function. The run_app.R file has the following content: #&#39; Run the Shiny App #&#39; #&#39; @param ... Arguments passed to `shiny::runApp()`. #&#39; @export run_app &lt;- function(...) { shiny::runApp(system.file(&quot;app&quot;, package = &quot;faithful&quot;), ...) } The #' style comments are used to add the documentation next to the function definition, which describes how other parameters can be passed to the shiny::runApp function. The @export tag signifies that the run_app function should be added to the NAMESPACE file by the roxygen2 package (Wickham et al. 2024). Calling R CMD build faithful will build the faithful_0.0.1.tar.gz source file. You can install this package using install.packages(\"faithful_0.0.1.tar.gz\", repos = NULL) from R or you can use the R command line utility: R CMD INSTALL faithful_0.0.1.tar.gz. Once the package is installed, you can call faithful::run_app() to start the Old Faithful example. If you want to include the app as part of the package’s functions, place it in the package’s R folder. In this case, shiny and all other packages will have to be mentioned in the package’s DESCRIPTION file, that describes the dependencies, as packages that the package imports from. Best practices can be found out there, both about writing R packages (Hadley and Bryan 2023), and about engineering Shiny apps using (Fay et al. 2021). You can not only test the underlying functions as part of the package, but you can apply Shiny specific testing tools, like shinytest2 (Schloerke 2024). An R package provides a structure to follow, and everything becomes a function. Including Shiny apps in R packages this way is much safer, and this is the approach that some of the most widely used Shiny development frameworks took. These are the golem (Fay et al. 2023), and the leprechaun (John Coene 2022) packages. 5.2.5.1 Golem The use and benefits of the Golem framework are described in the book Engineering Production-Grade Shiny Apps by Fay et al. (2021). Golem is an opinionated framework for building a production-ready Shiny apps by providing a series of tools doe developing you app, with an emphasis on writing Shiny modules. A Golem app is contained inside an R package. You’ll have to know how to build a package, but this is the price to pay for having a mature and trusted tools for testing your package from every aspect. Let’s review how the Golem structure compares to the previous setup. We will call this app faithfulGolem: # faithfulGolem ├── DESCRIPTION ├── LICENSE ├── NAMESPACE ├── R │ ├── app_config.R │ ├── app_server.R │ ├── app_ui.R │ ├── mod_histogram.R │ └── run_app.R ├── dev │ ├── 01_start.R │ ├── 02_dev.R │ ├── 03_deploy.R │ └── run_dev.R ├── inst │ ├── app │ │ └── www │ │ └── favicon.ico │ └── golem-config.yml └── man └── run_app.Rd The most important difference is that we see the UI and server added to the R folder as functions, instead of plain script files in the inst folder. The dev folder contains development related boilerplate code and functions to use when testing the package without the need to reinstall after every tiny change you make to the Shiny app or the R package in general. The inst folder has the static content for the app with the www folder inside. The DESCRIPTION file looks like this: Package: faithfulGolem Title: Old Faithful Shiny App Version: 0.0.1 Author: Peter Solymos Maintainer: Peter Solymos &lt;[...]&gt; Description: Old Faithful Shiny app. License: MIT + file LICENSE Imports: config (&gt;= 0.3.2), golem (&gt;= 0.4.1), shiny (&gt;= 1.8.1.1) Encoding: UTF-8 RoxygenNote: 7.3.1 Notice that the config and golem packages are now part of the list of dependencies with the package versions explicitly mentioned to avoid possible backwards compatibility issues. Let’s take a look at the UI and server functions. The app_ui function returns the UI as a tags list object. You might notice that we use a module UI function here: app_ui &lt;- function(request) { tagList( # Leave this function for adding external resources golem_add_external_resources(), # Your application UI logic fixedPage( title = &quot;Old Faithful&quot;, h2(&quot;Old Faithful&quot;), mod_histogram_ui(&quot;histogram_1&quot;) ) ) } The app_server function loads the Old Faithful data set and calls the histogram module’s server function that uses the same \"histogram_1\" identified as the module UI function, plus it also takes the data set as an argument too: app_server &lt;- function(input, output, session) { x &lt;- datasets::faithful$waiting mod_histogram_server(&quot;histogram_1&quot;, x) } So what does this module look like? That is what you can find in the R/mod_histogram.R file that defines the mod_histogram_ui and mod_histogram_server functions: mod_histogram_ui &lt;- function(id) { ns &lt;- NS(id) tagList( plotOutput(outputId = ns(&quot;histogram&quot;)), sliderInput( inputId = ns(&quot;n&quot;), label = &quot;Number of bins:&quot;, min = 1, max = 50, value = 25, ticks = TRUE ) ) } mod_histogram_server &lt;- function(id, x) { moduleServer(id, function(input, output, session) { ns &lt;- session$ns output$histogram &lt;- renderPlot( alt = &quot;Histogram of waiting times&quot;, { graphics::hist( x, breaks = seq(min(x), max(x), length.out = input$n + 1 ), freq = TRUE, col = &quot;#BB74DB&quot;, border = &quot;white&quot;, main = &quot;Histogram of waiting times&quot;, xlab = &quot;Waiting time to next eruption [mins]&quot;, ylab = &quot;Frequency&quot; ) graphics::box() } ) }) } After building, checking, and installing the faithfulGolem R package, you’ll be able to start the Shiny app by calling faithfulGolem::run_app() from R. FIXME: mention where to find the code for faithfulGolem. 5.2.5.2 Leprechaun The leprechaun R package (John Coene 2022) uses a similar philosophy to creating Shiny applications as packages. It comes with a full set of functions that help you with modules, custom CSS, and JavaScript files. When using this package, you will notice that leprechaun does not become a dependency in the DESCRIPTION file, unlike in the case of golem. Apart from this and some organization choices, the two packages and the workflow provided by them are very similar. Choose that helps you more in terms of your app’s specific needs. Say we name the the R package containing the Old Faithful example as faithfulLeprechaun. The main functions that are defined should be already familiar: # R/ui.R ui &lt;- function(req) { fixedPage( [...] ) } # R/server.R server &lt;- function(input, output, session) { x &lt;- datasets::faithful$waiting output$histogram &lt;- renderPlot( [...] ) } # R/run.R run &lt;- function(...) { shinyApp( ui = ui, server = server, ... ) } After the package is installed, the way to run the app is to call the faithfulLeprechaun::run() function. FIXME: mention where to find the code for faithfulLeprechaun. 5.2.6 Dynamic Documents Dynamic documents stem from the literate programming paradigm (Knuth 1992), where natural language (like English) is interspersed with computer code snippets. Nowadays, dynamic documents are used to create technical reports, slide decks for presentations, and books, like the one you are reading. Markdown is a common plain-text format for such dynamic documents, because it can be compiled into many different formats using Pandoc. R Markdown builds upon previous literate programming examples, e.g. Sweave that mixes R and (Leisch 2002), and the flexibility provided by Pandoc and the markdown format. R Markdown contains chunks of embedded R (or other) code between opening and closing triple backticks. Underneath, you can find the rmarkdown (Allaire et al. 2024) and knitr (Xie 2024) R packages at work. A more recent iteration of this idea is Quarto. Quarto is an open-source scientific and technical publishing system that can include code chunks in many different formats frequently used by data scientists (e.g. R, Python, Julia, Observable). Both R Markdown and Quarto let you to use Shiny inside the documents to build lightweight apps without worrying too much about a user interface. Such interactive HTML documents cannot provide the same flexibility for designing your apps as a standard Shiny app would, but it works wonders for simpler use cases. Let’s review how you can use Shiny in R Markdown (.Rmd) and Quarto (.qmd) documents. 5.2.6.1 R Markdown Markdown files usually begin with a header that defines metadata for the document, like the title, the author, etc. The header is between tripple dashes (---) and is written in YAML format (YAML stands for YAML Ain’t Markup Language). We’d like to include the Old Faithful example in an R Markdown document. So we create a file called index.Rmd. In the YAML header we need to specify an output format that produces HTML, e.g. html_document, and the runtime to be set to shiny: --- title: &quot;Old Faithful&quot; output: html_document runtime: shiny --- The first code chunk would contain the data set definition and a knitr option to set the echo to false so we don’t have to set it for every chunk: ```{r include=FALSE} knitr::opts_chunk$set(echo = FALSE) x &lt;- faithful$waiting ``` Next comes a code chunk with the slider widget: ```{r} sliderInput( inputId = &quot;n&quot;, label = &quot;Number of bins:&quot;, min = 1, max = 50, value = 25, ticks = TRUE ) ``` Finally, we render the plot output: ```{r} renderPlot( alt = &quot;Histogram of waiting times&quot;, { hist( x, breaks = seq(min(x), max(x), length.out = input$n + 1), freq = TRUE, col = &quot;#BB74DB&quot;, border = &quot;white&quot;, main = &quot;Histogram of waiting times&quot;, xlab = &quot;Waiting time to next eruption [mins]&quot;, ylab = &quot;Frequency&quot; ) box() } ) ``` FIXME: where can you find the full document. The output format can be any format tha creates an HTML file. So for example, you can use ioslides_presentation to create a slideshow with Shiny widgets and interactivity. But because Shiny is involved, you need a server to run the document. To render and run the document and the app inside it you can use rmarkdown::run(\"index.Rmd\"). As a result, the rmarkdown package will extract the code chunks to create a server definition and uses the index.html output file to stich in the reactive elements. When you start the document, you will notice that it always renders the document at startup. Not only that, but it also requires a full document render for each end user browser session when deployed. This startup time for the users can be reduced if we render the HTML only once. Running expensive data import and manipulation tasks only once would also greatly help the startup times. The runtime for this is called shinyrmd (or its alias, shiny_prerendered): --- title: &quot;Old Faithful&quot; output: flexdashboard::flex_dashboard runtime: shinyrmd --- We’ll use the flexdashboard (Aden-Buie et al. 2023) package to give the document more of a dashboard look and feel. The execution of pre-rendered Shiny documents is divided into two execution contexts, the rendering of the user interface and data, and the serving of the document to the users. To indicate the rendering context, you can use context=\"render\" chunk option, but this can be omitted because this is the default context for all R code chunks. The \"render\" is analogous of the ui.R file. For the first chunk, we define context=\"setup\" to mark code that is shared between the UI and the server. This is analogous to the global.R file. ```{r context=&quot;setup&quot;,include=FALSE} knitr::opts_chunk$set(echo = FALSE) x &lt;- faithful$waiting ``` We put the slider widget in the sidebar using the \"render\" context: Column {.sidebar} ------------------------------------------------------------- ```{r context=&quot;render&quot;} sliderInput( inputId = &quot;n&quot;, label = &quot;Number of bins:&quot;, min = 1, max = 50, value = 25, ticks = TRUE ) ``` The plot output element goes into the main panel, still as part of the \"render\" context: Column ------------------------------------------------------------- ```{r context=&quot;render&quot;} plotOutput(&quot;histogram&quot;) ``` Finally, we define the \"server\" context for the reactive output. This code is run when the interactive document is served and this is the same code that we would put into the server.R file: ```{r context=&quot;server&quot;} output$histogram &lt;- renderPlot( alt = &quot;Histogram of waiting times&quot;, { hist( x, breaks = seq(min(x), max(x), length.out = input$n + 1), freq = TRUE, col = &quot;#BB74DB&quot;, border = &quot;white&quot;, main = &quot;Histogram of waiting times&quot;, xlab = &quot;Waiting time to next eruption [mins]&quot;, ylab = &quot;Frequency&quot; ) box() } ) ``` The \"render\" and \"server\" contexts are run in separate R sessions. The first one is run when rendering happens, the second one is run many times, once for each user. A consequence of this context separation is that you cannot access variables created in “render” chunks within “server” chunks, and the other way around. To render the document, we use rmarkdown::render(\"index.Rmd\"), then use rmarkdown::run(\"index.Rmd\") to run the dashboard. You can also set the RMARKDOWN_RUN_PRERENDER environment variable to 0 to prevent any pre-rendering from happening, e.g. with Sys.setenv(RMARKDOWN_RUN_PRERENDER=0). You can include Python code chunks in your R Markdown documents. Python code is evaluated using the reticulate package (Ushey, Allaire, and Tang 2024). But you cannot include Shiny for Python in R Markdown. For that, you have Quarto. 5.2.6.2 Quarto with R Quarto is very similar to R Markdown in many respects. You can think of it as a generalized version of R Markdown that natively supports different programming languages to run code chunks. You will find the YAML header familiar. To use the Shiny runtime, we define server: shiny. The format: html is means to produce HTML output. The execute part refers to global options, so for echo: false means that example we don’t want to code to be echoed into the document. Let’s start with the following header information in a file called index.qmd: --- title: &quot;Old Faithful&quot; execute: echo: false format: html server: shiny --- The language is specified after the triple backticks, here {r} means R. What is different from R Markdown is that chunk options are defined as special comments prefaced with #| at the top of the code block instead of following the language declaration inside the curly brackets. UI elements belong to the render context, which is something we do not have to specify: ```{r} plotOutput(&quot;histogram&quot;) sliderInput( inputId = &quot;n&quot;, label = &quot;Number of bins:&quot;, min = 1, max = 50, value = 25, ticks = TRUE ) ``` The server-start context will share code and data across multiple user sessions. It will execute when the document is first run and will not re-execute for every new user. This is like our global.R file. ```{r} #| context: server-start x &lt;- faithful$waiting ``` We can set the context to server for the next chunk: ```{r} #| context: server output$histogram &lt;- renderPlot( alt = &quot;Histogram of waiting times&quot;, { hist( x, breaks = seq(min(x), max(x), length.out = input$n + 1), freq = TRUE, col = &quot;#BB74DB&quot;, border = &quot;white&quot;, main = &quot;Histogram of waiting times&quot;, xlab = &quot;Waiting time to next eruption [mins]&quot;, ylab = &quot;Frequency&quot; ) box() } ) ``` To render and serve this document we have to use the command quarto serve index.qmd. Pre-rendering our document to speed up startup times for the users is really straightforward. We do not have to change the server type. We only have to first render the document with quarto render index.qmd. Then we can serve it with a flag that will tell quarto not to render it again: quarto serve index.qmd --no-render. If you wanted to split the .qmd file into multiple files corresponding to the evaluation contexts, you can have the header and the UI definition in the index.qmd file. Put the code for the server-start context into the global.R file. The server.R file should return the server function: # server.R function(input, output, session) { output$histogram &lt;- renderPlot( alt = &quot;Histogram of waiting times&quot;, { hist( x, breaks = seq(min(x), max(x), length.out = input$n + 1), freq = TRUE, col = &quot;#BB74DB&quot;, border = &quot;white&quot;, main = &quot;Histogram of waiting times&quot;, xlab = &quot;Waiting time to next eruption [mins]&quot;, ylab = &quot;Frequency&quot; ) box() } ) } 5.2.6.3 Quarto with Python The Python version or our Quarto-based Shiny app is very similar to the R version. No change is headed in the header. The code chunks will have {python} defined instead of {r}, and of course you have to copy the Python code inside the chunks. --- title: &quot;Old Faithful&quot; execute: echo: false format: html server: shiny --- The next chunk contains the setup and loads libraries: ```{python} import seaborn as sns import matplotlib.pyplot as plt from shiny import App, render, ui faithful = sns.load_dataset(&quot;geyser&quot;) x = faithful.waiting ``` The UI elements, like the slider input control, come next: ```{python} ui.input_slider( id=&quot;n&quot;, label=&quot;Number of bins:&quot;, min=1, max=50, value=25, ticks=True) ``` Finally, the rendered plot: ```{python} @render.plot(alt=&quot;Histogram of waiting times&quot;) def histogram(): plt.hist( x, bins = input.n(), density=False, color=&quot;#BB74DB&quot;, edgecolor=&quot;white&quot;) plt.title(&quot;Histogram of waiting times&quot;) plt.xlabel(&quot;Waiting time to next eruption [mins]&quot;) plt.ylabel(&quot;Frequency&quot;) ``` Rendering and serving the Python document is the same you used for the R version: quarto serve index.qmd will do both, so for a pre rendered version, use quarto render index.qmd first and the serve with the --no-render flag. 5.2.7 Shinylive Using Shinylive, you can run Shiny applications entirely in a web browser, i.e. on the client side, without the need for a separate server running in R or Python. This is achieved by R or Python running in the browser. The Python implementation of Shinylive uses WebAssembly (WASM) and Pyodide. WASM is a binary format for compiled programs that can run in a web browser, whereas Pyodide is a port of Python and many Python packages compiled to WASM. 5.2.7.1 Python Shinylive We will create Python Shinylive version of the Hello Shiny app following the posit-dev/py-shinylive GitHub repository. First, export the app inside the py-shiny folder with the single-file app and put the Shinylive version in the py-shinylive folder: shinylive export python py-shinylive The Shiny live version will consist of static files, which means that we can copy these files to any static hosting site (like Netlify or GitHub Pages), and a browser will be able to display the contents irrespective of the underlying operating system, and without the need to have a Python available. Can we view the output locally? If you click on the index.html sitting in the py-shinylive folder, you will most likely get an error in the browser. To read the error you have to find the developer tools and check the error messages. You will see something like this: Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at file:///[...]/shinylive/shinylive.js. (Reason: CORS request not http). For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts. But what is this cross-origin resource sharing (CORS)? If you load the HTML file (like our index.html) from a source, the default CORS behaviour will expect any other files, like images, or JavaScript/CSS scripts to have the same origin. By origin, we mean the domain and subdomain. Now the problem here is that you are viewing a local version of the files, which will set the protocol part of the URIs to be file:// instead of http:// as indicated in the message. Although the folder following the file protocol is the same, but this is considered as having opaque origins by most browsers and therefore will be disallowed. If you want to view the files locally, you do it through a local server. That way, all files are served from the same scheme and domain (localhost) and have the same origin. Start the server as: python3 -m http.server --directory py-shinylive Now visit http://localhost:8000/ in your browser, and the CORS error should be gone (port 8000 is the default port for http.server). 5.2.7.2 R Shinylive Shinylive for R uses similar technology built on WebAssembly using the WebR R package. Here is how to create an R Shinylive version of the Hello Shiny app following the posit-dev/r-shinylive GitHub repository using the interactive R console: shinylive::export(&quot;r&quot;, &quot;r-shinylive&quot;) httpuv::runStaticServer(&quot;r-shinylive&quot;) The first line compiles the Shiny app that is inside the r-shiny folder into the Shinylive version in the r-shinylive folder. The second command will start the server and open the page in the browser. You will see a random port used on localhost, e.g. http://127.0.0.1:7446. 5.2.7.3 Shinylive in Quarto We can include Shinylive (R or Python) apps in Quarto. For that, we need to install the Shinylive quarto extension inside the Quarto project folder with quarto add quarto-ext/shinylive. The header of the Quarto document should list the shinylive extension under filter: --- title: &quot;Old Faithful&quot; format: html filters: - shinylive --- You can include the Shiny application code into a code chunk marked with {shinylive-r} or {shinylive-python}. Use the comment standalone: true which tells Quarto that the block contains a complete Shiny app, and not only parts of it, as we saw before. For R, we include the full single-file app. The viewerHeight: 500 comment is needed to have enough space for the UI: ```{shinylive-r} #| standalone: true #| viewerHeight: 500 [...] ``` The Python version uses {shinylive-python} and the Python version of the single-file Old Faithful Shiny app: ```{shinylive-python} #| standalone: true #| viewerHeight: 500 [...] ``` To view the Quarto document in your browser, use quarto preview index.qmd. This will work with the R and the Python versions alike. 5.3 Running Shiny Apps Locally When you are developing your app locally, you likely want to rin the app to check the look and see the changes that you’ve made. In the previous chapter we already used some of the commands needed to run the code. Let’s review the different ways of running Shiny for R and Python apps locally. Running your app locally is necessary for testing. Of course testing goes way beyond just opening up the app in the browser. We will not cover best practices for testing your app. If you are interested, you can read about R package based development in Fay et al. (2021) or check out the documentation for the shinytest2 R package (Schloerke 2024). For testing related the Python version, see the Tapyr project that used pytest and playwright for validation and testing. 5.3.1 R When the app is in a single R file, you should name it app.R just like we did previously for the faithful example. If you have multiple files, make sure that you have the server.R and ui.R files in the same directory. If you are using other frameworks, an app.R file usually serves as an entrypoint that your IDE will recognize. This way, you can run it easily inside of the RStudio IDE (Fig. 5.2) or VS Code with the Shiny extension (Fig. 5.3) by pushing the “▷ Run App” button. Clicking on button would run the app in either a simple browser window tab inside your IDE, or in a separate browser window, depending on your settings. Besides the app showing up in the browser, you can also see some messages appearing in your R console or terminal for Python. If you inspect the console output, you should see something like this: Running Shiny app ----------------- shiny::runApp(&quot;r-shiny/app.R&quot;, port = 52938) Loading required package: shiny shiny devmode - Turning on shiny autoreload. To disable, call `options(shiny.autoreload = FALSE)` This message is displayed once every 8 hours. Listening on http://127.0.0.1:52938 What does this mean? Pushing the Run App button led to running the runApp() command. This started a web server on localhost (127.0.0.1) listening on port 52938 (your port number might be different). If you visit the http://127.0.0.1:52938 address in your browser, you should see the Shiny app with the slider and the histogram. (Stop the app by closing the app window in RStudio or using CTRL+C). Running the app this way will allow you to keep the server running while making changes to the app source code. Your changes will trigger a reload so you can immediately see the results. You can disable this behavior by turning off the auto-reload option with options(shiny.autoreload = FALSE). Figure 5.2: Running an R Shiny app in the RStudio IDE. Figure 5.3: Running an R Shiny app in the VS Code IDE with the Shiny extension. The runApp() function can take different types of arguments to run the same app. What you saw above was serving the app from the single file. If you name the single file something else, e.g. my-app.R, you can provide the path to a single file as runApp(\"&lt;app-directory&gt;/my-app.R\"). You can start the Shiny app from the terminal using the command R -q -e 'runApp(\"&lt;app-directory&gt;/my-app.R\")' where the -q flag means to suppress the usual opening message, and -e instructs R to execute the expression following it. You can also specify the port number as argument, e.g. R -q -e 'runApp(..., path = 8080)' will start the web server on port 8080. Running these lines will start the Shiny server locally that you can visit in the browser. To be precise, the shinyApp() R function returns the app object which is run either by implicitly calling the print() method on it when running in the R console. You can also pass the app object to the runApp() function (you can stop the server by CTRL+C). R -q -e &#39;shiny::runApp(&quot;r&quot;, port = 8080)&#39; &gt; shiny::runApp(&quot;r&quot;, port = 8080) Loading required package: shiny Listening on http://127.0.0.1:8080 This pattern might be unusual for you if you are using R mostly in interactive mode through an IDE. You will see this pattern in the next chapters when we call R from the terminal shell. This is how we can start the web server process in non-interactive mode. 5.3.2 Python You can run the Python app from the RStudio IDE (Fig. 5.4) or VS Code (Fig. 5.5) by pushing the same “▷ Run App” button. You’ll see something like this in your console with localhost and a randomly picked and available port number (52938). python -m shiny run --port 52938 --reload [...] py-shiny/app.py INFO: Will watch for changes in these directories: [&#39;py-shiny&#39;] INFO: Uvicorn running on http://127.0.0.1:52938 (Press CTRL+C to quit) INFO: Started reloader process [85924] using WatchFiles INFO: Started server process [85926] INFO: Waiting for application startup. INFO: Application startup complete. INFO: 127.0.0.1:56050 - &quot;GET [...] HTTP/1.1&quot; 200 OK INFO: (&#39;127.0.0.1&#39;, 56053) - &quot;WebSocket /websocket/&quot; [accepted] INFO: connection open Running the Shiny app in Python relies on the Uvicorn web server library that can handle websocket connections. Figure 5.4: Running a Python Shiny app in the RSudio IDE. Figure 5.5: Running a Python Shiny app in the VS Code IDE with the Shiny extension. The other port number (56053) is for the websocket connection created for the session. If you open another browser window pointing to http://127.0.0.1:52938, you’ll see another websocket connection opening for the new session: # Opening another browser tab INFO: 127.0.0.1:56194 - &quot;GET / HTTP/1.1&quot; 200 OK INFO: (&#39;127.0.0.1&#39;, 56196) - &quot;WebSocket /websocket/&quot; [accepted] Use App(app_ui, server, debug=False) to suppress the messages. From the terminal, you can run the single app file from the terminal with shiny run --port 8080 &lt;app-directory&gt;/app.py on port 8080. If you change the output of the App() statement from the default app = App(...) to faithful_app = App(...), you have to define the app as well not just the file: shiny run &lt;app-directory&gt;/app.py:faithful_app. If the file is called app.py and the app object is called app, you can omit the file name and use shiny run, in this case app.py:app is assumed in the current working directory. Trying to run both the R and Python version on the same port at the same time will not be possible. If you want to run both, use different port numbers, e.g.  8080 and 8081. The shiny run command starts the app. You can use the --launch-browser flag to automatically launch the app in a web browser. The --reload flag means that the Python process restarts and the browser reloads when you make and save changes to the python/app.py file (use CTRL+C to stop the process). 5.3.3 The Shiny App Lifecycle The traditional way of serving Shiny apps involves a server that runs an R or Python process, and each client connects to this server and keeps an open websocket connection as long as they are using the application. Let’s take a closer look at this to better understand what is happening under the hood. Shiny for R relies on the httpuv (Cheng et al. 2024) package to handle connections. Whenever a new user connects to the Shiny app a new session is started and communication between the client and the user session will be happening through the websocket connection. The websocket allows two-way communication which is the basis of Shiny’s reactivity. The JavaScript code on the client side can communicate the the R process via this connection. In Python, the connections are handled by Uvicorn, and the messages – as we saw before – reveal the port numbers used for the different user sessions. Why is this important? Because user sessions having their own ports is the basis for isolating these sessions from one another. Users will not be able so access data from another session, unless data is leaked through the global environment (which should be avoided). The Shiny app life cycle can be described as follows (Fig. 5.6): Server start: after calling runApp() in R or shiny run for Python, the httpuv or Uvicorn server is started and is now listening on a random of a pre-defined port (e.g. 8080). Server ready: the application code is sourced including loading the required libraries, data sets, everything from the global scope; if users try to connect to the app before it is ready they will see an error message. Client connects to the app via the port over HTTP protocol. New session created: the backend server (httpuv or Uvicorn) starts a user session and runs the server function inside that session; a websocket connection is created for two-way communication. Client-server communication happening while the user is using the app: the server sends the rendered HTML content to the client, including the JavaScript code that will communicate with the server to send and receive data through the websocket connection. When the client detects that the websocket connection is lost, it will try to reconnect to the server. After a certain amount if inactivity, or in the case of disconnected client, the websocket connection and the user session will get terminated and the client browser will “gray out”. You can find more information about the Shiny app life cycle in Granjon (2022) and J. Coene (2021). Figure 5.6: The Shiny app life cycle with websocket connection. For Shinylive applications, the lifecycle does not include a websocket connection, and relies purely on HTTP(S) between the client and the server. The server will only send the requested resources to the client, and it will not do any other work. It will just “serve” these static files. The client browser will do the heavy lifting by rendering the HTML and running the Web Assembly binary that will take care of the reactivity. Such an application will not time out until the browser tab is closed. 5.4 Sharing the Shiny App Code The source code for the app can be shared with collaborators, clients, and users. They can run the app themselves if they are savvy enough. When the audiences of a Shiny app are R or Python users, it makes sense to share the app as a Gist, a GitHub repository, or a zip file. However, sharing Shiny apps, this leaves installing dependencies up to the user. You can email the files or the link to your users, you can even send a USB drive or a CD ROM in the mail. The shiny R package comes with a few useful functions that makes sharing your apps with technical users a bit easier. You can use the runUrl(), runGitHub(), and runGist() functions to run app from specific URLs, GitHub repositories, and Gists, respectively. runUrl() can be pointed at R files or compressed files, such as .zip. Another option is distributing your R Shiny app as an R package. This option takes care of dependency management. You can install the R package from different sources, like GitHub, and you can also have it hosted on CRAN. However, the recipients will have to be able to install the package from source, which implies familiarity with R and package management. Sharing the app source code is a low effort option on your part, but might be a high effort option for the ones you are sharing your app with. 5.5 Summary We reviewed all the different ways of how Shiny apps can be organized during development, from standalone R and Python applications to being part of dynamic documents. We also reviewed options for sharing your app’s code with others. Sharing the app source code has several issues when you are sharing it with non-technical users. First off, they will have to have an R or Python runtime environment. Second, they will have to have all the right dependencies installed, sometimes with specific versions of the libraries. As you will see in the next chapter, sharing the app as a Docker image is also an option. This might help with having a runtime environment and managing dependencies, but again, your users will need to understand and use Docker that can be often too much to ask for. So the real reason we are talking about Docker is that it can help you host the app. References Aden-Buie, Garrick, Carson Sievert, Richard Iannone, JJ Allaire, and Barbara Borges. 2023. Flexdashboard: R Markdown Format for Flexible Dashboards. https://CRAN.R-project.org/package=flexdashboard. Allaire, JJ, Yihui Xie, Christophe Dervieux, Jonathan McPherson, Javier Luraschi, Kevin Ushey, Aron Atkins, et al. 2024. Rmarkdown: Dynamic Documents for r. https://github.com/rstudio/rmarkdown. Cheng, Joe, Winston Chang, Steve Reid, James Brown, Bob Trower, and Alexander Peslyak. 2024. Httpuv: HTTP and WebSocket Server Library. https://CRAN.R-project.org/package=httpuv. Coene, J. 2021. Javascript for r. Chapman &amp; Hall/CRC the r Series. CRC Press. https://books.google.ch/books?id=ntUxEAAAQBAJ. Coene, John. 2022. Leprechaun: Create Simple ’Shiny’ Applications as Packages. https://CRAN.R-project.org/package=leprechaun. Fay, Colin, Vincent Guyader, Sébastien Rochette, and Cervan Girard. 2023. Golem: A Framework for Robust Shiny Applications. https://CRAN.R-project.org/package=golem. Fay, Colin, Sébastien Rochette, Vincent Guyader, and Cervan Girard. 2021. Engineering Production-Grade Shiny Apps. Chapman &amp; Hall. https://engineering-shiny.org/. Granjon, David. 2022. Outstanding User Interfaces with Shiny. Chapman &amp; Hall. https://unleash-shiny.rinterface.com/. Hadley, Wickham, and Jennifer Bryan. 2023. R Packages. 2nd ed. O’Reilly Media, Inc. https://r-pkgs.org/. Knuth, Donald. 1992. Literate Programming. Center for the Study of Language; Information—CSLI. Leisch, Friedrich. 2002. “Sweave, Part i: Mixing r and LaTeX.” R News 2: 28–31. Rudolph, Konrad. 2024. Box: Write Reusable, Composable and Modular r Code. https://CRAN.R-project.org/package=box. Schloerke, Barret. 2024. Shinytest2: Testing for Shiny Applications. https://CRAN.R-project.org/package=shinytest2. Ushey, Kevin, JJ Allaire, and Yuan Tang. 2024. Reticulate: Interface to ’Python’. https://CRAN.R-project.org/package=reticulate. Wickham, Hadley, Peter Danenberg, Gábor Csárdi, and Manuel Eugster. 2024. Roxygen2: In-Line Documentation for r. https://CRAN.R-project.org/package=roxygen2. Xie, Yihui. 2024. Knitr: A General-Purpose Package for Dynamic Report Generation in r. https://yihui.org/knitr/. Żyła, Kamil, Jakub Nowicki, Leszek Siemiński, Marek Rogala, Recle Vibal, Tymoteusz Makowski, and Rodrigo Basa. 2024. Rhino: A Framework for Enterprise Shiny Applications. https://CRAN.R-project.org/package=rhino. "],["6-containerizing-shiny-apps.html", "Chapter 6 Containerizing Shiny Apps 6.1 Docker Concepts 6.2 Working with Existing Images 6.3 Building a New Image 6.4 Managing Images and Containers 6.5 Sharing Images 6.6 The Dockerfile 6.7 Shiny Apps With Dependencies (use bananas) 6.8 Best Practices 6.9 WHAT ELSE 6.10 Container Orchestration 6.11 Troubleshooting 6.12 Summary", " Chapter 6 Containerizing Shiny Apps Containerization is a topic that is of increasing interest to data scientists and is a key feature for being able to cover the R and Python aspects of Shiny hosting in parallel. Once the container image is built, deployment and hosting become independent of the language that the app was written in. Tooling around this task has made huge advances over the past two years, and thanks to this, the topic is now accessible to a wider audience. Containerization enables you to separate your applications from your infrastructure so you can deliver software faster. Containerization help makes an application platform independent by creating virtual environments in a container. To run a specific application, you will need to develop an image for that platform which is then published on a container registry. The developed Image can be pulled from the registry to run a virtualized container environment for the application. Docker is one of the most popular tools for creating and managing containers for Shiny apps. This chapter will outline the needed concepts for containerizing your shiny application. Learning Docker seems daunting at first, but it is an incredibly powerful piece of technology once you get the hang of it. It is also the building block of the modern web. Docker is not the only tooling for containerizing applications. Docker’s licensing model has recently changed and can require a paid license for commercial use. Therefore, there are alternatives of the Docker engine such as using Podman. However, Podman is much more technical to use than Docker. All the general advantages of containerized applications apply to Shiny apps. Docker provides isolation to applications. Images are immutable: once build they cannot be changed, and if the app is working, it will work the same in the future. Another important consideration is scaling. Shiny apps are single-threaded, but running multiple instances of the same image can serve many users at the same time. Let’s dive into the details of how to achieve this. 6.1 Docker Concepts Containers provide portability, consistency, and are used for packaging, deploying, and running cloud-native data science applications. Docker is the most popular virtualization environment to deliver software in containers. DOcker is also well supported for Python and R. Among the many use cases, Docker is most commonly used to deploy reproducible workflows and to provide isolation for Shiny apps. Containers bundle their own software, libraries and configuration files and are isolated from one another. Containers are the run-time environments or instances defined by container images. Let’s review the most important concepts. Figure 6.1 illustrates how all the Docker-related concepts all fit together. Figure 6.1: The Shiny app life cycle with websocket connection. You as the user, will use the command line as the client to the Docker Engine which exists on a host machine. The Docker Engine interfaces with the container registry to pull the necessary images for building a local copy of an image on the host for running an instance of a container. 6.1.1 Docker Engine The Docker Engine is a client-server application that includes a server (a long-running daemon process called dockerd that listens to API requests), an application programming interface (REST API) that specifies the interface that programs can use to talk to the daemon process, and a command-line interface (CLI) that is the client-side of Docker. The CLI uses the REST API to control or interact with the Docker daemon. The daemon creates and manages Docker objects, such as images, containers, volumes, networks, etc. 6.1.2 Container Registries A Docker registry stores Docker images. Docker Hub is a public registry and Docker is configured to look for images on Docker Hub by default. There are many other registries, or users can have their own private registries. You will see some examples later. Strictly speaking, container registries are for images and not containers. 6.1.3 Images An image is a read-only template with instructions for creating a Docker container. You can view an image as a set of compressed files and metadata describing how these files – also called image layers – fit together. An image can be based on another image with additional customization on top of this so-called base or a parent image. A base images is an images created from scratch, whereas a parent image is just another image that serves as the foundation for a new image. You might see base image used for both situations when reading tutorials. Don’t get confused, the Docker lingo has a few inconsistencies that we just have to accept and move on. 6.1.4 The Dockerfile Docker builds images by reading the instructions from a file called Dockerfile. A Dockerfile is a text document that contains all the commands to assemble an image using the docker build CLI command. You will learn more about the Dockerfile as part of the worked Shiny examples later. 6.1.5 Containers A container is a runnable instance of an image. Users can create, start, stop a container using the Docker API or CLI. It is also possible to connect a container to networks or attach storage to it. By default, a container is isolated from other containers and the host machine. The degree of isolation can be controlled by the user and depends on whether it is connected to networks, storage, other containers, or the host machine. 6.1.6 The Docker Command Line The most common Docker CLI commands are: docker login: log into a Docker registry, docker pull: pull an image from a registry, docker build: build a Docker image based on a Dockerfile, docker push: push a locally built image to a Docker registry, docker run: run a command in a new container based on an image. You will learn more about these commands in the subsequent sections. 6.2 Working with Existing Images Let’s learn how to work with an existing image. Such an image is stored in a container registry where we can pull it from if we know its name. 6.2.1 Image Names and Tags Image names follow the pattern &lt;host&gt;/&lt;path&gt;:&lt;tag&gt;. The optional &lt;host&gt; name specifies where the image is located. If you don’t specify a host name, the commands will use Docker’s public registry docker.io, aka the Docker Hub. The &lt;path&gt; can be an “official” image, like ubuntu. The &lt;tag&gt; is a human-readable identifier that is often a specific version of an image. If not specified, the latest tag will be used. So ubuntu as an image name will be identical to docker.io/ubuntu:latest. It is important to note that the latest tag only means “latest” in the sense of the last image that was tagged as latest or was untagged. If you use a different tag, like v1, the image with the latest tag will not get updated as well. So don’t let this tag fool you. It is strongly recommended in production to always explicitly use a tag that is not latest but a specific version. The path is usually more structured and consists of slash-separated components. It often looks like &lt;namespace&gt;/&lt;repository&gt; where the namespace specifies the user account or organization to which the image belongs to. The base R image maintained by the Rocker project is names as rocker/r-base where rocker is the organization namespace, r-base is the repository. Another example is the R version of the Old Faithful example has the image name ghcr.io/h10y/faithful/r-shiny:latest which means: ghcr.io is the GitHub Container Registry host name, h10y is the GitHub organization, faithful is the GitHub repository, r-shiny is the Shiny app build, latest is the version tag. 6.2.2 Pulling an Image You can use the docker pull &lt;image-name&gt; command to pull an image from a public registry. For example docker pull ubuntu:24.04 will pull the 24.04 version of the “official” Ubuntu image from the Docker Hub. docker pull rocker/r-base:4.4.1 will pull the image with R version 4.1.1. Pull the R Shiny version of the Old Faithful as: docker pull ghcr.io/h10y/faithful/r-shiny # Using default tag: latest # latest: Pulling from h10y/faithful/r-shiny # Digest: sha256:12e[...]4ea You can see from the messages that the latest tag was applied because we did not specify the tag. We can also see the SHA256 digest, that is a unique and immutable identifier. The name can change, or multiple names can refer to the same image (i.e. a set of layers and their manifest). But the image digest will be the same. To “pin” the exact version, you can use the &lt;image-name&gt;@sha256:12e[...]4ea pattern: docker pull ghcr.io/h10y/faithful/r-shiny@sha256:12e[...]4ea To pull all images from a repository, you can use the --all-tags flag: docker image pull --all-tags ghcr.io/h10y/faithful/r-shiny This will pull not only the latest, but also the image tagged as main named after the Git branch. Use the docker images command to list the images. 6.2.3 Docker Login You don’t need to authenticate for public images, but in case you are trying to pull a private image from a private repository, you need to log into the container registry. Suck private repositories are common and are available on Docker Hub, the GitHub or GitLab container registries. More on the different container registries later. To log in to the GitHub container registry, use: docker login ghcr.io This command will ask for our credentials interactively. If you want, you can provide your username and password. But it is usually recommended to use a personal access token (PAT) instead of your password because PAT can have more restricted scopes, i.e. only used to (read) access the container registry which is a lot more secure. You can also set expiry dates and can revoke these tokens any time. Let’s say that you saved your PAT in a file ~/my_password.txt in the root of your home folder (~). You can pass the PAT value to the docker login command via the standard input as: cat ~/my_password.txt | docker login \\ --username &lt;username&gt; \\ --password-stdin where &lt;username&gt; is your GitHub username. 6.2.4 Running a Container The next command is docker run which runs a command in a new container. It pulls the image if needed before starting the container. Try the following command. It will pull the latest image for the Python build of the Old Faithful example app, then it will start a new container: docker run -p 8080:3838 ghcr.io/h10y/faithful/py-shiny The -p is a shorthand for --publish, that instructs Docker to publish a container’s port to the host port. In our example, 3838 is the container’s port which is mapped to port 8080 of the host machine. As a result, you can visit http://127.0.0.1:8080 in your browser to see the Python Shiny app. Hit CTRL+C to stop the container. We will learn about container ports in a bit, but in essence just a channel that the information is sent back and forth. 6.3 Building a New Image So far you saw how to use the basic Docker commands to pull and run images. Now you’ll build a Docker image by recreating the Old Faithful Shiny app that we worked with before. In our examples, we will use the following setup: a file named Dockerfile sits next to a folder names app, and the Shiny app files like app.R or app.py are in this folder. This setup is convenient because we can copy all the files from teh app folder without having to worry about copying files that should not be there. ├── Dockerfile └── app └── ... 6.3.1 R for Shiny FIXME: Link here the repo and folder. For our R Shiny example this is what is inside the Dockerfile: FROM rocker/r2u:24.04 RUN R -q -e &quot;install.packages(&#39;shiny&#39;)&quot; RUN groupadd app &amp;&amp; useradd -g app app WORKDIR /home/app COPY app . RUN chown app:app -R /home/app USER app EXPOSE 3838 CMD [&quot;R&quot;, &quot;-e&quot;, &quot;shiny::runApp(host=&#39;0.0.0.0&#39;, port=3838)&quot;] We will explain the Dockerfile commands in the next section. For now, you can use the docker build command to build the image from the Dockerfile. You will have to be in the same directory as the Dockerfile, this place is what we’ll call as the build context. This is what the . at the end of the command stands for: docker build -t r-shiny:v1 . The context here specifies the current directory (.), but it can be any relative or absolute filepath. Files and directories inside the context directory are available to the builder, so it can load them when needed. You can use a .dockerignore file to list files and directories that should be ignored within the build context. It is similar to the .gitignore file. The instructions are taken from the Dockerfile at the root of the build context. If you want to specify a different file, do so by providing the path to the file using the -f (or --file) option as docker build -f Dockerfile2 .. The -t argument (same as --tag) is followed by the image name (r-shiny-test) and the tag (v1). If you do not specify the image name/tag at image build (i.e. docker build .), Docker will not tag the image but it will have an image ID that you can use later to tag the image with docker tag &lt;image-id&gt; r-shiny-test:v1. You can apply multiple tags as: docker build -t r-shiny:v1 -t r-shiny:latest . 6.3.2 Buildx and BuildKit While the builder is running, you’ll see lots of messages printed as Docker goes through the instructions from the Dockerfile. Newer Docker Desktop version use buildx, which brings extended build capabilities with BuildKit, such as As of Docker Engine 23.0 and Docker Desktop 4.19, Buildx is the default build client and user interface. Buildx brings extended build capabilities with BuildKit. BuildKit is the server that handles the build execution, e.g. it communicates with registries, instructs the Docker Engine and accesses the local file system. The Buildx output is nicer and it provides you with timings for every step of your Dockerfile: [+] Building 32.4s (12/12) FINISHED =&gt; [internal] load build definition from Dockerfile 0.0s =&gt; =&gt; transferring dockerfile: 282B 0.0s =&gt; [internal] load metadata for docker.io/rocker/r2u:24.04 1.2s =&gt; [auth] rocker/r2u:pull token for registry-1.docker.io 0.0s =&gt; [internal] load .dockerignore 0.0s =&gt; =&gt; transferring context: 2B 0.0s =&gt; [1/6] FROM docker.io/rocker/r2u:24.04@sha256:f327[...]dd73 9.2s =&gt; =&gt; resolve docker.io/rocker/r2u:24.04@sha256:f327[...]dd73 0.0s [...] =&gt; [internal] load build context 0.0s =&gt; =&gt; transferring context: 845B 0.0s =&gt; [2/6] RUN groupadd app &amp;&amp; useradd -g app app 0.7s =&gt; [3/6] RUN R -q -e &quot;install.packages(&#39;shiny&#39;)&quot; 20.9s =&gt; [4/6] WORKDIR /home/app 0.0s =&gt; [5/6] COPY app . 0.0s =&gt; [6/6] RUN chown app:app -R /home/app 0.1s =&gt; exporting to image 0.3s =&gt; =&gt; exporting layers 0.3s =&gt; =&gt; writing image sha256:4d10[...]bab7 0.0s =&gt; =&gt; naming to docker.io/library/r-shiny:v1 0.0s Sometimes you want to inspect the output and do not only want the collapsed output. Add the --progress=plain to the build command to see all the output. This comes handy when you want to troubleshoot. BuildKit also offers other nice features, for example setting the target platform(s) for the build via the --platform option. The default value is the platform of the BuildKit daemon where the build runs, i.e. your laptop of a server. This can be important for Mac OS X users on Apple Silicone (M1 and above), because the default ARM64 build will have poor performance or might fail on other platforms on AMD64 machines. Use the --platform=linux/arm64 to build the image for AMD64 architecture. You can also build for multiple architectures at once with docker build --platform linux/amd64,linux/arm64 .. 6.3.3 Inspecting the Image The output of the build is an image that has a SHA256 hash that can be used as a unique identifier. The image is made up of image layers. These layers are created by the instructions from the Dockerfile. If you run the build command again you will notice that instead of 32 seconds, it will take almost no time to build the image. This is because the layers are cached by default and Docker smartly evaluates which instructions and files have changed since the last build. Sometimes the cache gets tangled, or you just want to make sure that the error is not a caching issue. In this case use the --no-cache flag with docker build. You can use the docker history r-shiny:v1 command to see how the image was built and you can see the sizes for every layer. Intermediate layers have a size of 0B and these do not contribute to the overall image size. The layers created 2 hours ago are the layers we created, the layers created 2 weeks ago are the layers from the parent image rocker/r2u:24.04, whereas the layers created 2 months ago are the official ubuntu:24.04 image layers that form the parent image of the rocker/r2u:24.04 one: IMAGE CREATED CREATED BY SIZE 4d[...]52 2 hours ago CMD [&quot;R&quot; &quot;-e&quot; &quot;shiny::runApp(host=&#39;0.0.0.0&#39;, 0B &lt;missing&gt; 2 hours ago EXPOSE map[3838/tcp:{}] 0B &lt;missing&gt; 2 hours ago USER app 0B &lt;missing&gt; 2 hours ago RUN /bin/sh -c chown app:app -R /home/app # 780B &lt;missing&gt; 2 hours ago COPY app . # buildkit 780B &lt;missing&gt; 2 hours ago WORKDIR /home/app 0B &lt;missing&gt; 2 hours ago RUN /bin/sh -c R -q -e &quot;install.packages(&#39;sh 109MB &lt;missing&gt; 2 hours ago RUN /bin/sh -c groupadd app &amp;&amp; useradd -g ap 5.14kB &lt;missing&gt; 2 weeks ago RUN /bin/sh -c apt-get update &amp;&amp; apt 642MB &lt;missing&gt; 2 weeks ago ENV TZ=UTC 0B &lt;missing&gt; 2 weeks ago ENV DEBIAN_FRONTEND=noninteractive 0B &lt;missing&gt; 2 weeks ago ENV LANG=en_US.UTF-8 0B &lt;missing&gt; 2 weeks ago ENV LC_ALL=en_US.UTF-8 0B &lt;missing&gt; 2 weeks ago RUN /bin/sh -c useradd -s /bin/bash -m docke 81.6MB &lt;missing&gt; 2 weeks ago LABEL org.label-schema.license=GPL-2.0 org.l 0B &lt;missing&gt; 2 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B &lt;missing&gt; 2 months ago /bin/sh -c #(nop) ADD file:ac9d5a9d5b9b1217 76.2MB &lt;missing&gt; 2 months ago /bin/sh -c #(nop) LABEL org.opencontainers. 0B &lt;missing&gt; 2 months ago /bin/sh -c #(nop) LABEL org.opencontainers. 0B &lt;missing&gt; 2 months ago /bin/sh -c #(nop) ARG LAUNCHPAD_BUILD_ARCH 0B &lt;missing&gt; 2 months ago /bin/sh -c #(nop) ARG RELEASE 0B The docker inspect r-shiny:v1 returns a long JSON output that is the metadata of the image. It also has the SHA256 hash of the image. Here is the greatly stripped output: [ { &quot;Id&quot;: &quot;sha256:4d10[...]bab7&quot;, &quot;RepoTags&quot;: [&quot;r-shiny:v1&quot;], &quot;Created&quot;: &quot;2024-07-05T04:59:01.123398172Z&quot;, &quot;Config&quot;: { &quot;User&quot;: &quot;app&quot;, &quot;ExposedPorts&quot;: {&quot;3838/tcp&quot;: {}}, &quot;Cmd&quot;: [&quot;R&quot;,&quot;-e&quot;, &quot;shiny::runApp(host=&#39;0.0.0.0&#39;, port=3838)&quot;], &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;/home/app&quot;, &quot;Entrypoint&quot;: null, }, &quot;Architecture&quot;: &quot;amd64&quot;, &quot;Os&quot;: &quot;linux&quot;, &quot;Size&quot;: 909132976, &quot;Metadata&quot;: { &quot;LastTagTime&quot;: &quot;2024-07-05T06:20:22.2764725Z&quot; } } ] Once the docker image is built, you can run the container to make sure the app is working as expected: docker run -p 8080:3838 r-shiny:v1 6.3.4 R for Python FIXME: provide link to this example. The Dockerfile for the Python version looks like this: FROM python:3.9 COPY app/requirements.txt . RUN pip install --no-cache-dir --upgrade -r requirements.txt RUN groupadd app &amp;&amp; useradd -g app app WORKDIR /home/app COPY app . RUN chown app:app -R /home/app USER app RUN mkdir .config ENV MPLCONFIGDIR=/home/app/.config ENV HOME=/home/app EXPOSE 3838 CMD [&quot;uvicorn&quot;, &quot;app:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;3838&quot;] Again, we’ll explain each line shortly. To build anc check the Docker image, use the following commands: docker build -t py-shiny:v1 . docker run -p 8080:3838 py-shiny:v1 6.4 Managing Images and Containers To list the Docker images, use the docker images command. It will give you a quick summary of the images: REPOSITORY TAG IMAGE ID CREATED SIZE py-shiny v1 ed11a2980c07 5 seconds ago 1.24GB r-shiny v1 4d10f42d6a52 About an hour ago 909MB Try the docker ps command which lists the containers. If you have a container running, you will see it listed with status Up. If you stopped all the containers by exiting with CTRL+C, you will not see any running containers listed. To see the stopped but not removed containers, use the docker ps -a command: CONTAINER ID IMAGE COMMAND CREATED [...] 3d91a5a2a47f r-shiny:v1 &quot;R -e &#39;shiny::runApp…&quot; 3 minutes ago [...] 3d91a5a2a47f r-shiny:v1 &quot;R -e &#39;shiny::runApp…&quot; 53 minutes ago [...] Sometimes you need to be able to manage containers because the kill signal is not properly relayed to the container when using CTRL+C. This happens when the CMD instruction is provided in shell form (i.e. CMD R -e \"shiny::runApp()\" instead of CMD [\"R\", \"-e\", \"shiny::runApp()\"]). The shell form runs as a child process of /bin/sh -c (default ENTRYPOINT), and the executable does not receive Unix signals. If this happens, you need to find a way to stop the container. The following commands help you manage the containers: docker container stop &lt;container-id&gt;: gracefully stop a running container (wait for the process to stop), docker container start &lt;container-id&gt;: start a stopped container, docker container restart &lt;container-id&gt;: restart a container, docker container rm &lt;container-id&gt;; remove a container, docker container kill &lt;container-id&gt;: kill a container (abruptly terminate the entry point process). docker container rm --force &lt;container-id&gt; will remove running containers too. You can make sure the container is removed after CTRL+C if you add the --rm option to automatically remove the container when it exits. If you build images during development while keeping the image name and tag the same you will end up with “dangling” images that are untagged and are not used any longer. Dangling images can accumulate over time and fill up the available space that Docker Desktop is allocating for images. Use docker system prune to clean up these dangling images. The command docker system prune -a will remove all unused images and containers. Dangling images docker system prune or all image layers with docker system prune -a to save up space (sometimes the available space for your docker desktop (64GB?) fills up – see the bottom of you desktop UI). 6.5 Sharing Images As we saw, Docker images are just compressed files linked by metadata. You should be able to copy these files and move them around. The docker save command lets you save an image to a compressed tar file: docker pull r-shiny:v1 docker save -o r-shiny-v1.tar r-shiny:v1 Next, you take this tar file, copy it to another server and load it with: docker load --input r-shiny-v1.tar Now imagine that you are managing more than two machines, or you want to share the Docker image with others so that they can use it or to serve as a parent image. The save/copy/load workflow becomes cumbersome quickly. In this case, using a registry might be a much better idea. There are many options to choose from, and you can even host your own registry. 6.5.1 Pushing Images Let’s tag the r-shiny image so that it has a host defined: docker tag r-shiny:v1 ghcr.io/h10y/faithful/r-shiny:latest Now we can push the locally built Docker image to a container registry: docker push ghcr.io/h10y/faithful/r-shiny:latest Note that this command will not work on your machine because you do not have write access to the ghcr.io/h10y/faithful repository. You need to create an image tag that would let you push for example to your own personal Docker Hub account. The image tag should start with the registry name unless you are pushing to Docker Hub. When the image tag is not specified, Docker will treat the new image as :latest automatically. 6.5.2 Docker Registries A Docker registry stores Docker images. This is where we push images to and pull images from. Docker Hub is a public registry and Docker is configured to look for images on Docker Hub by default. Docker Hub is a service provided by Docker for finding and sharing container images. The canonical host name for Docker Hub is docker.io. This is the default registry when you don’t specify a registry host as part of the image name. There are many other registries out there besides Docker Hub. Here is a non-exhaustive list of options. The GitHub Container Registry (GHCR) is available as part of GitHub Packages for free and paid plans, even for private repositories under the free plan. This registry requires no authentication for public images, otherwise you have to authenticate using your GitHub token. The visibility of the images inherits the repository visibility but can be change by the owner. The host name for GHCR is ghcr.io. An alternative to GitHub is GitLab (host name registry.gitlab.com), that has provided registry support for its free (public and private) repositories long before GitHub. The registry is tightly integrated with GitLab’s CICD pipelines. This registry also needs login with a token ofr private images. Heroku is a platform provider and it also comes with a Docker registry (host name is registry.heroku.com) where the Docker-based deployments push the images to. Of course, every major cloud provider offers a Docker container registry that is often integrated with their other offerings. Latency should be minimal due to network proximity to the servers: Amazon Elastic Container Registry Azure Container Registry Google Container Registry DigitalOcean Container Registry Other common alternatives for container registries include the JFrog Container Registry, Harbor, and Scaleway. Although these services are called “container registry”, but strictly speaking they store container images. 6.5.3 Log In to a Registry When you work with private registries or private images, you need to log in with the docker login command. For Docker Hub, just type docker login. For all other registries, type in the registry URL as well, e.g. docker login ghcr.io. The Docker CLI then will prompt you for your username and password (or access token). You can log in programmatically by providing your username and the password through standard input from a file: cat ~/my_password.txt | docker login -u USER --password-stdin You can also use an environment variable to store your token value that you can pass to the login command as: export TOKEN=&lt;your-token-value&gt; echo $TOKEN | docker login ghcr.io -u USER --password-stdin Notice the white space before the export statement, use double spaces so that the command after the spaces will not be saved in your shell history. The history allows you to recall previous commands by pushing the up arrow key. The shell history is really just a text file, so copy pasting secrets into the terminal will leave a trace. Use one of these approaches to log into any public or private repository for which you have credentials. The credentials will be stored locally in $HOME/.docker/config.json on Linux and Mac or in %USERPROFILE%/.docker/config.json on Windows. After login, there is no need to re-authenticate until you log out with docker logout. Note that docker login requires users to use sudo or be root in most cases. It is always a good idea to use a token instead of your password. Tokens can have limited scope (i.e. only for pulling images), and can be revoked at any time without it impacting other areas of your life. 6.5.4 Local Registry You might not want the Docker images to leave your computer because you need an air gapped environment, or you are setting up a registry within your virtual private network (VPN). In these situations, you can host your own container registry. If you want a registry hosted on your machine, just pull the registry image. The next command will pull the registry image, and run the similarly named container in the background on port 5000: docker run -d \\ # daemonixed background process -p 5000:5000 \\ # expose port --restart=always \\ # restart after errors --name registry \\ # give it a name registry:2 # image name and version tag Tag an image with the host name of your local registry, localhost:5000, and push the image: docker tag r-shiny:v1 localhost:5000/r-shiny:v1 docker push localhost:5000/r-shiny:v1 To test if it worked, remove the images from your local Docker system. If you use the -f flag and specify the image ID then the docker rmi command untags and removes all images that match that ID (get the image ID from docker images): docker rmi -f &lt;image_id&gt; Now you can pull the image from your local registry: docker pull localhost:5000/r-shiny:v1 The next command stops and removes the registry container. It is a daemonized (background) process, so CTRL+C won’t work. The -v option makes sure to remove anonymous volumes associated with the container which is often used to mount a volumes from your hard drive into the container where the images are stored: docker container stop registry &amp;&amp; \\ docker container rm -v registry If you want your registry to be accessed over a public network, then you need to think about security and access control. You’ll have to set up transport layer security (TLS) for HTTPS and user authentication, which are advanced topics and we recommend using a commercial container registry that we listed above and use private repositories to control access to your images. 6.6 The Dockerfile Let’s review the Dockerfiles line by line. The full Dockerfile reference can be found here. The FROM instruction initializes a new build stage and sets the base image. Take the latest r-base image from the rocker project (see on Docker Hub): FROM rocker/r-base:latest The LABEL instruction is optional, it adds metadata to an image, e.g. who to contact in case of issues or questions: LABEL maintainer=&quot;USER &lt;user@example.com&gt;&quot; The RUN instruction executes the command in a new layer (a layer is a modification to the image) on top of the current image. The following command updates the base image with a couple of libraries that are required by Shiny and related R packages (system dependencies): RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\ sudo \\ libcurl4-gnutls-dev \\ libcairo2-dev \\ libxt-dev \\ libssl-dev \\ libssh2-1-dev \\ &amp;&amp; rm -rf /var/lib/apt/lists/* The following RUN command uses the littler command-line interface shipped with the r-base image to install the Shiny package and its dependencies: RUN install.r shiny The next command sets the options in the Rprofile.site file which are going to be loaded by the R session. These options specify the Shiny host and port that runApp will use. Do not run containers as root in production. Running the container with root privileges allows unrestricted use which is to be avoided in production. Although you can find lots of examples on the Internet where the container is run as root, this is generally considered bad practice. Switching to the root USER opens up certain security risks if an attacker gets access to the container. In order to mitigate this, switch back to a non privileged user after running the commands you need as root. – Hadolint rule DL3002 The following command creates a Linux group and user, both called app. This user will have access to the app instead of the default root user: RUN addgroup --system app \\ &amp;&amp; adduser --system --ingroup app app You can read more about security considerations here and Dockerfile related code smells here. Read about best practices and linting rules in general that can be helpful in reducing vulnerabilities of your containerized application. The WORKDIR instruction sets the working directory for subsequent instructions. Change this to the home folder of the app user which is /home/app: WORKDIR /home/app The COPY instruction copies new files or directories from the source (our app folder containing the R script files for our Shiny app) and adds them to the file system of the container at the destination path (. refers to the current work directory defined at the previous step): COPY app . The next command sets permissions for the app user: RUN chown app:app -R /home/app In general, use the shell form for RUN, and the exec form for CMD and ENTRYPOINT. https://emmer.dev/blog/docker-shell-vs.-exec-form/ The USER instruction sets the user name (or UID) and optionally the user group (or GID) to use when running the image: USER app The EXPOSE instruction tells Docker which ports the container listens on at runtime. Set this to the Shiny port defined in the Rprofile.site file: EXPOSE 3838 Finally, the CMD instruction closes off our Dockerfile. The CMD instruction provides the defaults for an executing container. There can only be one CMD instruction in a Dockerfile (only the last CMD will take effect). Our CMD specifies the executable (\"R\") and parameters for the executable in an array. The -e option means you are running an expression that is shiny::runApp('/home/app'). The expression will run the Shiny app that we copied into the /home/app folder: CMD [&quot;R&quot;, &quot;-e&quot;, &quot;shiny::runApp(&#39;/home/app&#39;)&quot;] In general, use the shell form for RUN, and the exec form for CMD and ENTRYPOINT. https://emmer.dev/blog/docker-shell-vs.-exec-form/ Build the image using docker build by specifying the tag (-t) and the context (. indicates the current directory): docker build -t registry.gitlab.com/analythium/shinyproxy-hello/hello . You can test and push the locally build Docker image to the container as before. 6.6.0.1 Shiny host and port When we discussed local hosting of Shiny apps and runApp, we did not review all the possible arguments for this R function. Besides the app location (app object, list, file, or directory) there are two other important arguments: host: this defines the IP address (defaults to ‘localhost’: 127.0.0.1), port: TCP port that the application should listen on; a random port when no value provided. When you run the shiny app locally, you see a message Listening on http://127.0.0.1:7800 or similar, which is the protocol (HTTP), the host address, and the port number. The Shiny app is running in a web server that listens to client requests and provides a response. 6.7 Shiny Apps With Dependencies (use bananas) What makes programming languages like R and Python great for making data applications is the wealth of contributed extension packages that supercharge app development. You can turn your code into an interactive web app with not much extra code once you have a workflow and an interesting question. We have reviewed Docker basics and how to dockerize a very simple Shiny app. For anything that is a little bit more complex, you will have to manage dependencies. Dependency management is one of the most important aspects of app development with Docker. In this post, you will learn about different options. 6.7.1 Parent Images In the previous post, we explored dependency management for Shiny apps using the rocker/r-ubuntu:20.04 as the parent image. A parent image is an image that you define in the FROM directive of the Dockerfile. A base image has FROM scratch as the first line. The R base images start with parent images. For example, the R Ubuntu image starts with FROM ubuntu:focal. Here are the four commonly used parent images for R: docker pull rhub/r-minimal:4.0.5 docker pull rocker/r-base:4.0.4 docker pull rocker/r-ubuntu:20.04 docker pull rstudio/r-base:4.0.4-focal The image sizes vary quite a bit with the Alpine Linux base rhub/r-minimal being smallest and the Ubuntu-based rstudio/r-base 25x the size of the smallest image: $ docker images --format &#39;table {{.Repository}}\\t{{.Tag}}\\t{{.Size}}&#39; REPOSITORY TAG SIZE rhub/r-minimal 4.0.5 35.3MB rocker/r-base 4.0.4 761MB rocker/r-ubuntu 20.04 673MB rstudio/r-base 4.0.4-focal 894MB The Debian Linux based rocker/r-base Docker image from the Rocker project is considered bleeding edge when it comes to system dependencies, i.e. latest development versions are usually available sooner than on other Linux distributions. The two Ubuntu Linux based images, rocker/r-ubuntu and rstudio/r-base from the Rocker project and from RStudio are for long-term support Ubuntu versions and use the RSPM CRAN binaries. The Alpine Linux based rhub/r-minimal Docker image from the r-hub project is preferred for its small image sizes. FIXME: add FROM Scratch, ubuntu, alpine 6.7.1.1 Rocker, r-lib, rstudio (posit???) We built the same Shiny app in three different ways. The sizes of the three images differ quite a bit, with the :renv image being 40% bigger than the other two images: $ docker images --format &#39;table {{.Repository}}\\t{{.Tag}}\\t{{.Size}}&#39; REPOSITORY TAG SIZE analythium/covidapp-shiny renv 1.7GB analythium/covidapp-shiny deps 1.18GB analythium/covidapp-shiny basic 1.24GB The :basic image has 105 packages installed (try docker run analythium/covidapp-shiny:basic R -q -e 'nrow(installed.packages())'). The  :deps image has remotes added on top of these, the :renv image has remotes, renv and BH as extras. BH seems to be responsible for the size difference, this package provides Boost C++ header files. The COVID-19 app works perfectly fine without BH. In this particular case, this is a price to pay for the convenience of automatic dependency discovery provided by renv. The renv package has a few different snapshot modes. The default is called “implicit”. This mode adds the intersection of all your installed packages and those used in your project as inferred by renv::dependencies() to the lockfile. Another mode, called “explicit”, only captures packages that are listed in the project DESCRIPTION file. For the COVID-19 app, both these resulted in identical lockfiles. You can use renv::remove(\"BH\") to remove BH from the project or use the “custom” model and list all the packages to be added to the lockfile. If you go with the other two approaches, explicitly stating dependencies in the Dockerfile or in the DESCRIPTION file, you might end up missing some packages at first. These approaches might need a few iterations before getting the package list just right. Another important difference between these approaches is that renv pins the exact package versions in the lockfile. If you want to install versioned packages, use the remotes::install_version() function in the Dockerfile. The version-tagged Rocker images will by default use the MRAN snapshot mirror associated with the most recent date for which that image was current. FIXME: add Shiny Server inside a container as a way to host multiple apps FIXME: layers &amp; caching vs size, why using alpine is not always needed 6.7.2 system libraries First of all, each package lists its system requirements. These are usually run-time dependencies that the package needs to properly function. So check that first. There are at least two databases listing package requirements: one maintained by RStudio (this supports RSPM, you can browse the database here), another one by R-hub. Both of these list system packages for various Linux distributions, macOS, and Windows. But even with these databases, the build- vs. run-time dependencies can be sometimes hard to distinguish. Build-time system libraries are always named with a -dev or -devel postfix. Read the vignette of the maketools R package by Jeroen Ooms for a nice explanation and a suggested workflow for determining run-time dependencies of packages. 6.7.2.1 RSPM, BSPM, r2u, python? 6.7.3 R dependencies The wealth of contributed R packages can supercharge Shiny app development. This also means that you have to manage these dependencies. Learn about dependency management when working with R and Docker. When building Docker images for your R-based applications, the biggest hurdle is knowing exactly which packages and system libraries your package depends on. Luckily, the tools have evolved quite a bit over the past few years. In this post, I show you where the deps package fits in and how this can be a great choice for dependency management for Docker-based workflows. Tools like packrat, renv, and capsule let you go to great lengths to make your R projects perfectly reproducible. This requires knowing the exact package versions and the source where it was installed from (CRAN, remotes, local files). This information is registered in a lock file, which serves as the manifest for recreating the exact replica of the environment. Full reproducibility is often required for reports, markdown-based documents, and scripts. A loosely defined project that is combined with strict versioning requirements, often erring on the side of “more dependencies are safer”. On the other end of the spectrum, we have package-based development. This is the main use case for dependency management-oriented packages, such as remotes and pak. Note that pak is to replace remotes at some point in the future. In this case, exact versions are managed only to the extent of avoiding breaking changes (given that testing can surface these). So what we have is a package-based workflow combined with a “no breaking changes” philosophy to version requirements. This approach often leads to leaner installation. 6.7.3.1 explicit dependencies The first approach is to use RUN statements in the Dockerfile to install the required packages. Check the Dockerfile in the 03-docker-basic folder. The structure of the Dockerfile follows the general pattern outlined in this post. We use the rocker/r-ubuntu:20.04 parent image and specify the RStudio Package Manager (RSPM) CRAN repository in Rprofile.site so that we can install binary packages for speedy Docker builds. Here are the relevant lines: FROM rocker/r-ubuntu:20.04 ... COPY Rprofile.site /etc/R ... RUN install.r shiny forecast jsonlite ggplot2 htmltools RUN Rscript -e &quot;install.packages(&#39;plotly&#39;)&quot; ... Required packages are installed with the littler utility install.r (littler is installed on all Rocker images). You can also use Rscript to call install.packages(). There are other options too, like install2.r from littler, or using R -q -e install.packages() – -q suppresses the startup message, -e executes an expression then quits. Build and test the image locally, use any image name you like (in export IMAGE=\"\"), then visit http://localhost:8080 to see the app: # name of the image export IMAGE=&quot;analythium/covidapp-shiny:basic&quot; # build image docker build -t $IMAGE . # run and test locally docker run -p 8080:3838 $IMAGE 6.7.3.2 DESCRIPTION file, remotes &amp; pak The second approach is to record the dependencies in the DESCRIPTION file. You can find the example in the 04-docker-deps folder. The DESCRIPTION file contains basic information about an R package. The file states package dependencies and is used when installing the packages and their dependencies. The install_deps() function from the remotes package can install dependencies stated in a DESCRIPTION file. The DESCRIPTION file used here is quite rudimentary but it states the dependencies to be installed nonetheless: Imports: shiny, forecast, jsonlite, ggplot2, htmltools, plotly Use the same Ubuntu-based R image and the RSPM CRAN repository. Install the remotes package, copy the DESCRIPTION file into the image. Call remotes::install_deps() which will find the DESCRIPTION file in the current directory. Here are the relevant lines from the Dockerfile: FROM rocker/r-ubuntu:20.04 ... COPY Rprofile.site /etc/R ... RUN install.r remotes COPY DESCRIPTION . RUN Rscript -e &quot;remotes::install_deps()&quot; ... Build and test the image as before, but use a different tag: # name of the image export IMAGE=&quot;analythium/covidapp-shiny:deps&quot; # build image docker build -t $IMAGE . # run and test locally docker run -p 8080:3838 $IMAGE 6.7.3.3 renv The renv package is a versatile dependency management toolkit for R. You can discover dependencies with renv::init() and occasionally save the state of these libraries to a lockfile with renv::snapshot(). The nice thing about this approach is that the exact version of each package is recorded that makes Docker builds reproducible. Switch to the 05-docker-renv directory and inspect the Dockerfile. Here are the most important lines (Focal Fossa is the code name for Ubuntu Linux version 20.04 LTS that matches our parent image): FROM rocker/r-ubuntu:20.04 ... RUN install.r remotes renv ... COPY ./renv.lock . RUN Rscript -e &quot;options(renv.consent = TRUE); \\ renv::restore(lockfile = &#39;/home/app/renv.lock&#39;, repos = \\ c(CRAN=&#39;https://packagemanager.rstudio.com/all/__linux__/focal/latest&#39;))&quot; ... We need the remotes and renv packages. Then copy the renv.lock file, call renv::restore() by specifying the lockfile and the RSPM CRAN repository. The renv.consent = TRUE option is needed because this is a fresh setup (i.e. not copying the whole renv project). Tag the Docker image with :renv and build: # name of the image export IMAGE=&quot;analythium/covidapp-shiny:renv&quot; # build image docker build -t $IMAGE . # run and test locally docker run -p 8080:3838 $IMAGE 6.7.3.4 deps What if we are not writing an R package and wanted to combine the best of both approaches? – A loosely defined project with just strict-enough versioning requirements. All this without having to write a DESCRIPTION file by hand. Because why would you need a DESCRIPTION file when you have no package? Also, a DESCRIPTION file won’t let you pin an exact package version or specify alternative CRAN-like repositories. What if you could manage dependencies by decorating your existing R code with special, roxygen-style comments? Just like this: #&#39; @remote analythium/rconfig@CRAN-v0.1.3 rconfig::config() #&#39; @repo sf https://r-spatial.r-universe.dev library(sf) #&#39; @ver rgl 0.108.3 library(rgl) This is exactly what deps does: helps to find all dependencies from our files, writes these into a dependencies.json file, performs package installs according to the decorators. The decorators make our intent explicit, just like if we were writing an R package. But we do not need to manually write these into a file and keep it up-to-date. We can just rerun create to update the JSON manifest file. There are many different tags that you can use as part of your roxygen-style comments. These tags are listed and explained in the package’s GitHub repository. The deps package has 2 main functions: create() crawls the project directory for package dependencies. It will amend the dependency list and package sources based on the comments and query system requirements for the packages where those requirements are known for a particular platform; the summary is written into the dependencies.json file. install() looks for the dependencies.json file in the root of the project directory (or runs create() when the JSON file is not found) and performs dependency installation according to the instructions in the JSON file. In the simplest case, one might have a project folder with some R code inside. Running deps::install() will perform the package installation in one go. Additional arguments can be passed to install() so that local libraries etc. can be specified. These arguments are passed to install.packages(). This is a really important consideration when it comes to utilizing RSPM or BSPM repositories on Linux systems. RSPM (RStudio Package Manager) provides rebuild binaries, BSPM (Bridge to System Package Manager) provides full system dependency resolution and integration with apt on top of binary packages. The deps package helps users be more intentional about the R package source and version requirements using text decorators in comments. This is similar to a package-based workflow without actually writing a package. But deps also lends itself to Dockerized development. It identifies system requirements for the R packages, which is a welcome addition to making the Docker experience for R as user-friendly and hands-off as possible. 6.7.3.5 Using the deps CLI FIXME: explain the deps CLI, note that it also works with pak, etc. 6.7.4 Python requirements FIXME: KALVIN to add here 6.7.4.1 pip FIXME: KALVIN to add here 6.7.4.2 Other options for python ??? Conda, venv??? FIXME: KALVIN to add here 6.8 Best Practices The use of Docker with R has been transformative in many ways over the past 5 years. What is common in this diversity of use cases is that the Docker images almost always start with a parent image. What parent image you use? How do you add new layers to it? These questions will determine how quickly you can iterate while in development, and the size of the final image you send to production. In this post, I will compare using different parent images and outline best practices. I focus on Shiny apps but most of these ideas apply generally to any dockerized R application, like images for compute jobs or interfaces. Based on these results and the list of Dockerfile best practices, here are a few suggestions to improve the developer experience and the quality of the final Docker images. 6.8.1 Minimize dependencies 6.8.1.1 Minimize dependencies Avoid installing “nice to have” packages and do not start from general-purpose parent images aimed at interactive use. Images for Shiny apps and other web services benefit from keeping the images as lean as possible by adding those R packages and system requirements that are absolutely necessary. Multi-stage builds can be helpful to only include artifacts that are needed. 6.8.2 Use caching When building an image, Docker executes each instruction in the order specified in the Dockerfile. Docker looks for an existing image in its cache that it can reuse, rather than creating a new (duplicate) image. Only the instructions RUN, COPY, ADD create layers: for the RUN instructions, just the command string from the Dockerfile is used to find a match from an existing image; for the ADD and COPY instructions, the contents of the file(s) in the image are examined and a checksum is calculated for each file; the last-modified and last-accessed times of the file(s) are not considered in these checksums for the ADD and COPY instructions. 6.8.3 Order layers Caching can be useful is when installing R package dependencies. In a previous post, we looked at how to use the renv package to install dependencies. Here is a simplified snippet from that Dockerfile: ## install dependencies COPY ./renv.lock . RUN Rscript -e &quot;renv::restore()&quot; ## copy the app COPY app . What would happen if we switched the two blocks? ## copy the app COPY app . ## install dependencies COPY ./renv.lock . RUN Rscript -e &quot;renv::restore()&quot; You would have to wait for the build to reinstall all the R packages whenever the app files have changed. This is because once the cache is invalidated all subsequent Dockerfile commands generate new images instead of using the cache. It is best to order the instructions in your Dockerfile from the less frequently changed to the more frequently changed. This ensures that the build cache is reusable. Figure 6.2: Docker layers for single (left) and multi-stage builds (right). Dashed lines are temporary layers. 6.8.4 Switch user Running the container with root privileges allows unrestricted use which is to be avoided in production. Although you can find lots of examples on the Internet where the container is run as root, this is generally considered bad practice. Use something like this: RUN addgroup --system app \\ &amp;&amp; adduser --system --ingroup app app WORKDIR /home/app COPY app . RUN chown app:app -R /home/app USER app 6.8.5 Multi-stage Builds 6.8.6 Other considerations 6.8.6.1 Use a linter Best practices for writing Dockerfiles are being followed more and more often according to this paper after mining more than 10 million Dockerfiles on Docker Hub and GitHub. However, there is still room for improvement. This is where linters come in as useful tools for static code analysis. Hadolint lists lots of rules for Dockerfiles and is available as a VS Code extension. Dockerfile best practices Hadolint rules Tips to Speed up Your Docker Image Build–&gt; 6.8.6.2 Use labels 6.8.6.3 Docker Security Scanning This brings up an important consideration when it comes to production code and environments. Knowing the exact versions of your packages is not only good for reproducibility but is also the foundation for vulnerability scanning. R users are familiar with the renv package and how it registers the exact version of the R packages being used. However, it does not register anything about the underlying system libraries, the version of curl or openssl or GDAL libraries being used. This is what a Software Bill Of Materials (SBOM) is used for. For this reason, Docker Desktop 4.7.0 introduced the experimental docker sbom CLI command that is based on a collaboration with the Syft project. Reproducibility is concerned with keeping the versions immutable. It is like a vintage car that is used once a year to derive to the car show. As opposed to this, in production, we are more concerned with acting on the information and upgrade packages when necessary while also making sure that our app is running flawlessly. It is like how people drive their kids to dance and soccer practice 7 days a week in a minivan. The car is maintained continuously because there is no room for error. The docker scan CLI command was introduced to quickly detect and learn how to remediate vulnerabilities in your images. Vulnerability scanning for Docker local images allows developers and development teams to review the security state of the container images and take actions to fix issues identified during the scan, resulting in more secure deployments. Docker Scan runs on Snyk engine, providing users with visibility into the security posture of their local Dockerfiles and local images. Users trigger vulnerability scans through the CLI, and use the CLI to view the scan results. The scan results contain a list of Common Vulnerabilities and Exposures (CVEs), the sources, such as OS packages and libraries, versions in which they were introduced, and a recommended fixed version (if available) to remediate the CVEs discovered. Another popular vulnerability scanner for container images and filesystems is called Grype. You will find links to some tutorials below walking through the use of Syft and Grype. SBOM was announced in 2022. Here is the original announcement about SBOM from Docker in April 2022: making what is inside your container images more visible so that you can better secure your software supply chain Announcing Docker SBOM: Increased Docker Image Visibility https://www.docker.com/blog/announcing-docker-sbom-a-step-towards-more-visibility-into-docker-images/ Image visibility and transparency are key to securing your software supply chain. Learn how our Docker SBOM feature highlights core image components. Here is a short intro to how docker sbom command and the Syft project are related (Syft supports the OCI, Docker, and Singularity image formats): How to Improve Docker Security with docker sbom and Syft Grype can use the SBOM output or scan the Docker image or local file system directly. Then it performs a vulnerability scan by comparing the package versions to information found in vulnerability databases. This tutorial outlines the whole process: Container vulnerability scan with Syft and Grype How to add a Software Bill of Materials (SBOM) to your containers with GitHub Actions: You might use GitHub actions to build a new image every time you merge changes to your production branch. It can be important to make sure there are no vulnerabilities. This post outlines how to do that: 6.9 WHAT ELSE 6.9.1 Layers and Caching 6.9.2 Hardware Architectures 6.9.3 Multi-stage builds 6.9.4 Mounting volumes 6.9.5 Ports 6.9.6 UID 6.9.7 Troubleshooting FIXME: Accessing the logs: FIXME: how to enter a running container to find runtime info 6.9.8 Shinylive Shinylive: R &amp; Python using Nginx and of-watchdog 6.9.9 Rmd Rmd: this is for R 6.9.10 Quarto Quarto: R &amp; Python 6.9.11 Using BuildKit Docker versions 18.09 or higher come with a new opt-in builder backend called BuildKit. BuildKit prints out a nice summary of each layer including timing for the layers and the overall build. This is the general build command that I used to compare the four parent images: DOCKER_BUILDKIT=1 docker build --no-cache -f $FILE -t $IMAGE . BuildKit backend is enabled by turning on the DOCKER_BUILDKIT=1 environment variable. I use the --no-cache option to avoid using cached layers, thus having a fair assessment of build times (you usually only build 1 and not 4). The -f $FILE flag allows building from different files kept in the same folder. All the code used here can be found in our Covid-19 Shiny app GitHub repository, look in the folder 99-images. 6.9.11.1 Image build times This is the script I used to build the four images with BuildKit: # rhub/r-minimal export IMAGE=&quot;analythium/covidapp-shiny:minimal&quot; export FILE=&quot;Dockerfile.minimal&quot; DOCKER_BUILDKIT=1 docker build --no-cache -f $FILE -t $IMAGE . # rocker/r-base export IMAGE=&quot;analythium/covidapp-shiny:base&quot; export FILE=&quot;Dockerfile.base&quot; DOCKER_BUILDKIT=1 docker build --no-cache -f $FILE -t $IMAGE . # rocker/r-ubuntu export IMAGE=&quot;analythium/covidapp-shiny:ubuntu&quot; export FILE=&quot;Dockerfile.ubuntu&quot; DOCKER_BUILDKIT=1 docker build --no-cache -f $FILE -t $IMAGE . # rstudio/r-base export IMAGE=&quot;analythium/covidapp-shiny:focal&quot; export FILE=&quot;Dockerfile.focal&quot; DOCKER_BUILDKIT=1 docker build --no-cache -f $FILE -t $IMAGE . I changed the CRAN repository for the Debian and Ubuntu Rocker images to see timing differences between installing packages as binary or from source. Total build times (on a 6-year old MacBook Pro) were the following: rhub/r-minimal: 27 minutes with building packages from source rocker/r-base: 12 minutes when building from source, 2.9 minutes when installing binary packages rocker/r-ubuntu: 12 minutes when building from source, 3.2 minutes when installing binary packages rstudio/r-base: 3.1 minutes with installing binary packages The difference between the binary vs. source package installs is expected. What is interesting is the 12 vs. 27 minutes between the Debian/Ubuntu images and the minimal Alpine image. Is it worth waiting for? 6.9.11.2 Image sizes I got the image sizes from docker images and made a small data frame in R to calculate the size difference between the final and parent images: x = data.frame(TAG=c(&quot;minimal&quot;, &quot;base&quot;, &quot;ubuntu&quot;, &quot;focal&quot;), PARENT_SIZE=c(35, 761, 673, 894) / 1000, # base image FINAL_SIZE=c(222 / 1000, 1.05, 1.22, 1.38)) # final image x$DIFF = x$FINAL_SIZE - x$PARENT_SIZE # TAG PARENT_SIZE FINAL_SIZE DIFF # 1 minimal 0.035 0.222 0.187 # 2 base 0.761 1.050 0.289 # 3 ubuntu 0.673 1.220 0.547 # 4 focal 0.894 1.380 0.486 The image sizes themselves differed quite a bit, the RStudio Ubuntu image was 6.2x larger than the minimal R image. Size differences were similarly different. Image sizes can be deceiving. It might not matter much if images are large if for example, we have multiple images sharing some of the layers (i.e. ones from the parent image). The CPU and RAM footprint of the containers might also be unrelated to the image sizes. But it might impact “cold start” performance when images are pulled to an empty server. 6.9.11.3 Alpine Linux based image The Dockerfiles and the build experience for the Ubuntu and Debian images were very similar. Build times and image sizes were also comparable. The Alpine Linux-based minimal image took the longest time to build but resulted in the smallest image size. The Dockerfile for this setup also looks quite different from the Debian/Ubuntu setup: FROM rhub/r-minimal:4.0.5 RUN apk update RUN apk add --no-cache --update-cache \\ --repository http://nl.alpinelinux.org/alpine/v3.11/main \\ autoconf=2.69-r2 \\ automake=1.16.1-r0 \\ bash tzdata RUN echo &quot;America/Edmonton&quot; &gt; /etc/timezone RUN installr -d \\ -t &quot;R-dev file linux-headers libxml2-dev gnutls-dev openssl-dev libx11-dev cairo-dev libxt-dev&quot; \\ -a &quot;libxml2 cairo libx11 font-xfree86-type1&quot; \\ remotes shiny forecast jsonlite ggplot2 htmltools plotly Cairo RUN rm -rf /var/cache/apk/* RUN addgroup --system app &amp;&amp; adduser --system --ingroup app app WORKDIR /home/app COPY app . RUN chown app:app -R /home/app USER app EXPOSE 3838 CMD [&quot;R&quot;, &quot;-e&quot;, &quot;options(tz=&#39;America/Edmonton&#39;);shiny::runApp(&#39;/home/app&#39;, port = 3838, host = &#39;0.0.0.0&#39;)&quot;] The base image is so bare-bones that it needs to install time zones, fonts and the Cairo device for ggplot2 to work (read the limitations here). Instead of apt you have apk and might have to work a bit harder to find all the Alpine-specific dependencies. One interesting aspect of this image is that instead of the littler utilities familiar from the Rocker images, we have the very similar installr script that installs R packages and system requirements: the -d flag installs then removes compilers ( gcc, musl-dev, g++), as these are typically not needed on the final image; system packages listed after the -t flag are removed after the R packages have been installed; system packages listed after the -a flag are run-time dependencies that are needed for the packages to function properly and are not removed from the image. The installation of the system packages – that are all available on the other parent images – contributes to the longer build times. The BuildKit output gives you a clue about where exactly the time was spent. The rest of the Dockerfile is very similar to the other distributions: add Linux user, copy files, expose port, define the entrypoint command. But how do you figure out what system packages you need? 6.10 Container Orchestration 6.10.1 Docker Compose 6.11 Troubleshooting FIXME: Enter the containers etc. to see variables etc. 6.12 Summary With the newfound ability to wrap any Shiny app in a Docker container, you’ll be able to deploy these images to many different hosting platforms. Of course, there is a lot more to learn, e.g. about handling dependencies, persisting data across sessions and containers, and so on. We’ll cover these use cases in due time. Until then, celebrate this milestone, check out further readings, and try to containerize some of your own Shiny apps. You can also share Docker images with others. This, however, will require the recipient of your app to have Docker installed and be able to run it locally. In the next Part, we’ll cover options for hosting your app, so that others will only need a browser to be able to access it. No R, Python, or Docker runtime environment is needed on the user’s part. Hosting the app for your users will also be the preferred option in case you do not want to share the source code or the Docker image with the users. Further reading: Get started with Docker Docker simplified Docker for beginners Docker glossary The Docker Handbook R Docker tutorial Docker for R users An Introduction to Rocker The Rockerverse "],["7-a-review-of-shiny-hosting-options.html", "Chapter 7 A Review of Shiny Hosting Options 7.1 Start with the why 7.2 List your requirements 7.3 Identify your constraints 7.4 Options at a glance 7.5 Hosting Patterns 7.6 The Cloud 7.7 Custom Domain Names 7.8 Reverse Proxies 7.9 Monitoring Processes 7.10 Systemctl 7.11 Shutdown and Reboot 7.12 Networking/Firewalls 7.13 Static Shiny Apps 7.14 Dynamic Shiny Apps 7.15 Deploying Static Files with Shinylive 7.16 Deploying Shiny Apps to Shinyapps.io", " Chapter 7 A Review of Shiny Hosting Options The Hosting Data Apps website recently celebrated its 6-months anniversary. During this time I have written 40 posts, almost all about Shiny hosting options. Some of these posts reviewed particular hosting options, such as Shinyapps.io, Shiny Server, Heroku, and ShinyProxy. A lot has been said about the hosting options themselves, but what about the needs of the developers and the users? The most important question to ask is: “which option is better for what**“? This is where developers and the users of the app come into the picture with their specific needs and constraints. You could say, for example, that “I want to host my portfolio for free and I don’t care about a custom domain name”. Or a nonprofit might say, “we want to host our apps at low cost, we want custom domains, and we want to be able to handle surge traffic, but we don’t want to maintain any servers”. These are really specific criteria, and if you ask me, I might say Shinyapps.io is best for you and Heroku with a Docker-based deployment is best for this organization. But how would you or I make such a decision? If you have been developing Shiny apps, you might already have your preferred way of deployment. But as your needs evolve, you will identify additional requirements and might find that your go-to option is not the best anymore. Then you’ll do some research and find the next option. If you are not yet familiar with Shiny hosting options, you still need to make an informed choice at some point, so that you are not wasting your time and effort on something that will not serve you well over the long run. Here is the 3 step process that you can follow to help you with this decision. Before you begin take a piece of paper. 7.1 Start with the why Why do you want the app or apps deployed? Are you building a portfolio to boost your career? Are you deploying useful apps for stakeholders or clients of your organization? Are you trying to sell an app as a software-as-a-service (SaaS) offering? Write down your answer. Getting clear on the why is the most important question. You might even realize that you don’t need to host your Shiny app. For example, your app might be used on a laptop as a GUI to analyze data by non-specialists in the field without internet or cell coverage. In this case, no need to move on to step 2, because all you need is to run Shiny locally. However, if your answer makes it clear to you that your users will be accessing the app over the Internet, move on to step 2. 7.2 List your requirements Answering the Why question will probably reveal important details about your motivations, your audience, the number of apps you are going to host, etc. The answer will also bring you closer to identifying the requirements that you’ll need. For example, do you need a custom domain, how many users are you expecting, do you need authentication or app-level authorization? Do you want to host a single app or do you need to host many apps? Will you host non-Shiny apps? Write these down too. The following table lists the important features for many different Shiny hosting options. The table lists tiers offered by the same company as a separate option. Use this table to find the options that meet your requirements. For now, just ignore the columns inside the blue rectangle. If you crave a more interactive experience, I made a filterable version: View the video of it here: https://www.youtube.com/watch?v=iGKQMKuz-ww. Visit https://hosting.analythium.io/assets/files/shiny-hosting-options.html to filter the options and pick the right hosting option for your Shiny app. Once you filter the table according to your requirements, you’ll see a list of your ideal hosting options. Put these in the file or onto the paper too. 7.3 Identify your constraints The last step involves identifying your constraints: What is your budget? What is your current skill level? How much time do you have time? Recognizing these constraints will guide you toward an optimal solution. This is the point where the columns inside the blue rectangle come in. The Total Cost of Ownership (TCO) (USD/year) covers licensing fees and operating costs for the “Number of Apps” listed in the table. Prices range quite a bit from free to the tens of thousands. Price increases with performance and with the availability of enterprise features, such as custom domains and authentication. PaaS means platform-as-a-service, i.e. it is a fully managed system without you having to worry about the underlying infrastructure. This also means less control over the infrastructure, i.e. when it comes to choosing the data region where your app is served from. Unlimited app hours are more common for self-hosted options or paid PaaS plans including a single app. The need to host multiple apps will involve some compromises. The ability to host non-Shiny apps (Dahs, Streamlit, etc.) is a feature for RStudio Connect and the Docker-based options (Shinyapps and Shiny Server can host Shiny for Python). Time as a constraint will depend on how far your current skill level is from the level needed for a specific hosting option. You also have to consider that some options are fully managed PaaS offerings, others you have to manage, or learn how to use Docker. If you have to develop new skills, it might take longer. If you have to manage your servers, it will take more time to get started and then you are on the hook for maintaining your setup. Make your selections inside the columns within the blue area. 7.4 Options at a glance After the 3-step process, you should see only a few or a single option left. Click on the name of the hosting option and the link will take you to the relevant tag page on the Hosting Data Apps website: Follow the instructions in the tutorials to get started At the end of each post, you’ll find a Further reading section listing additional resources If there is no option left in the table, then you might need to be more realistic about your expectations or relax some of your constraints. For example, to keep costs low, you could spend more time and invest in skill development. But if you have more room in your budget, you might choose a different path. You can also revise your requirements until you find an acceptable solution. The following diagram gives an intuitive overview of the different options. The vertical axis represents the total cost from the table above: free, low, and high cost. The horizontal axis shows a range of skills you need to set up and manage your hosting solution. It can be as simple as pushing a button, or as complex as managing servers or cloud clusters. The hosting options in this diagram are not separated by tiers but rather shown as spanning over a range. The fill colours identify Docker and non-Docker-based options, the stroke styling indicates the PaaS solutions. Starting November 28, 2022, free Heroku Dynos, free Heroku Postgres, and free Heroku Data for Redis will no longer be available – see this FAQ for details. If you followed the 3-step process to collect all the information you need, it is likely that you have found an option that is best for your needs. Now go ahead and learn more about that option, deploy, and start hosting your app. Shiny is a very popular interactive data application framework. As a result, new hosting options are popping up every time. As the number of these hosting options grows in the future, I might update this post by adding the new contenders to the table. If you know a Shiny hosting option that is not listed in the table, add that to this form so that I can include it next time! 7.5 Hosting Patterns Include here: Hosting Patterns for Shiny Apps Web applications can run statically or dynamically. If running statically, then a backend server is not required as all the necessary content is pre-generated. Dynamic web applications require a backend server to render pages. The pros of hosting an app statically include a small app size and fast loading speed, the ability to be hosted for free, improved SEO, and content decoupling. However, the cons are that the app is the same for all users and not reactive. One benefit of a dynamically hosted app is the provision of user-specific content along with full reactivity facilitated by websockets. However, the drawbacks include the tendency to be resource-hungry, slow initial loading times, challenges with SEO optimization, more complex hosting requirements, and the high performance costs. Both static and dynamic apps can be hosted on platforms, or servers that you manage. In this chapter, we want to build the intuition behind the different kinds of hosting options and choosing the option that best suits your needs. To connect to a hosted application, a reverse proxy is required. A reverse proxy sits in front of your web application and forwards browser requests to your web application. It is used to create a secure connection to your web application and to distribute the load of user requests to your web application. A reverse proxy also helps to route requests to a domain sent by a client to the server to the appropriate web application. In this chapter we dive into reverse proxies, static Shiny apps, dynamic Shiny apps, and custom domain names. 7.6 The Cloud The cloud refers to remote servers that are available for rent at a cost. Often the costs of these remote servers are charged by the hour. The cloud is part of IaaS (Infrastructure as a Service) where server infrastructure can be provided on demand. Some of the post popular cloud services include: DigitalOcean AWS EC2 Akami (Linode) Google Cloud Platform Vultr These service can spin up a server for you to remotely connect to in minutes. This remote connection can be done via the command line as we have described in Part 3. 7.6.1 Servers You might be wondering, what plan do I choose or how do I get started? In this section, we want to highlight the general intuition behind getting started with a cloud provider. We will outline the concepts of the different options when choosing a server plan for a cloud provider. For our examples, we will be using DigitalOcean. However, the same principles apply to different cloud providers. CPU RAM OS IP Address (IPV4 vs IPV6) SSH Key Later we will talk about securing your server instance. 7.7 Custom Domain Names Custom domain names are important for giving an easy to access url for your Shiny application. It is important for branding memorability. To obtain a custom domain, you must register a domain with a registrar. The registrar leases you a domain name from the domain registry annually for a nominal fee. You must renew your domain name every year. Each domain extension (e.g. .com) has its own registry. Some common domain name registrars are NameCheap, NameSilo, and Porkbun. Domain names are linked to a name server that helps resolve to an IP address of a server that returns content to a client. On the domain name server (DNS), the A record entry helps resolve a name to an IPV4 address. The AAAA record entry helps resolve a name to an IPV6 address. Lots of websites have shifted to using IPV4 in addition to IPV6. It is recommended that you at least have an IPV4 record as not everybody has an IPV6 connection. A fully registered domain name is one of the requirements for an HTTPS certificate. 7.8 Reverse Proxies There are different options of reverse proxies such as: Nginx, Apache, and Caddy. One of the easiest to use and configure is Caddy. Caddy uses HTTPS automatically and by default. It obtains and renews TLS certificates for your sites automatically, and comes with lots of handy features. HTTPS is important because it encrypts the traffic between the client and server. It ensures that the data sent to the client from the server is not tampered with and vice-versa. To use this section, we assume that you have setup a linux server. Start a Ubuntu 20.04 virtual machine and follow instructions from the introductory ShinyProxy post to have the server available on http://$HOST:8080 with the two demo applications. For a Let’s Encrypt certificate, you need a fully registered domain name and an email address. I use the example.com domain here, you have to substitute your domain name. Add an A record with example.com pointing to your server’s public IP address. 7.8.1 Install Caddy Log in to the server (ssh root@$HOST) and follow the instructions: sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https curl -1sLf &#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key&#39; | sudo apt-key add - curl -1sLf &#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt&#39; | sudo tee /etc/apt/sources.list.d/caddy-stable.list sudo apt update sudo apt install caddy After installing Caddy with apt it will already be running as a service. It is also enabled (see output from systemctl is-enabled caddy), which means that it will restart with the system. Visit http://$HOST to see the Caddy welcome page: Make a text file called Caddyfile: touch Caddyfile then nano Caddyfile, and add the following content. Make sure you add your domain name to the 1st line, or just use :80 if you want to serve Shiny apps without custom domain and over HTTP, replace your email in the global configuration block (some challenges and Let’s Encrypt notifications require the email, but this block is optional): { email your.name@example.com } yourdomain.com { reverse_proxy 0.0.0.0:3838 } Save (CTRL+O) and exit (CTRL+X) nano. Now copy the file to the /etc/caddy/Caddyfile location. With this you make sure that systemctl will restart the Caddy server according to the new specifications: sudo cp Caddyfile /etc/caddy/Caddyfile Use systemctl reload caddy to apply the changes. Now Caddy will be busy in the background setting up transport layer security (TLS) certificates for HTTPS. Use journalctl -u caddy --no-pager | less to view the logs of what is happening behind the scenes. Visit https://yourdomain.com to see the Shiny Server welcome page. The two demo apps are located at https://yourdomain.com/sample-apps/hello/ and https://yourdomain.com/sample-apps/rmd/. That’s it! You can now disable port 3838 with sudo ufw delete allow 3838. HTTP requests will redirect to HTTPS. Finally, don’t forget to destroy the server if you don’t need it anymore. This is the time to save a machine image for future use, such images cost very little. Caddy server makes it super easy to obtain TLS certificates for your custom domain and to serve Shiny apps securely over HTTPS on top of the open-source Shiny Server. 7.9 Monitoring Processes Often times, you might need to check if a specific program is running on your remote computer, or you would like to know the memory or CPU that is currently being used. By typing the top command you can get a live view of the processes currently running on your computer. At the top you can see the total time your computer has been running for. The %cpu row shows how much of the CPU is being used. The us stands for user time of the cpu, while the sy stands for the system of the CPU. Below the %cpu row is the MiB Mem row which shows the amount of memory that is consumed in megabytes. And the MiB Swap which is the hard disk space used for RAM. Finally, there are the live processes in a table below the top heading. You can see the command that has been executed and the amount of CPU and memory it has been using. To quit top, simply press the q character on your keyboard. FIXME: add used/free disk space commands. 7.10 Systemctl Enable, start, stop, log, restart/reload system processes. FIXME: SHOULD THIS GO INTO THE HOSTING CHAPTER WHEN DEALING WITH VM’S? I think we should mention it here… 7.11 Shutdown and Reboot You may need to reboot or shutoff your server at times. These commands will require super user access as you may be interrupting the operations of other users on the server. Therefore to reboot the server, you would run: sudo reboot. To shut off the server, you would run: sudo poweroff. If you do shut off the server, you will have to turn it back on in your cloud hosting provider panel. Or if it is a physical server, you can also physically press the power button. 7.12 Networking/Firewalls ufw commands. Talk about securing the app with firewall. 7.12.1 systemd 7.13 Static Shiny Apps 7.13.1 Compiling without containers (R vs Python) 7.13.2 Compiling with containers 7.13.3 Static Hosting Options GitHub Pages, netlify, surge.sh File Server 7.14 Dynamic Shiny Apps 7.14.1 Hosting platforms (PaaS) Heroku DO App Platform Fly etc Cloud Services (AWS, AZURE) We do not want to focus too much on hosting platforms. But give the intuition to use any hosting platform. 7.14.2 Reverse Proxy Required Non-container hosting (R vs Python): Posit Connect ShinyServer systemd or pm2 ShinyProxy 7.15 Deploying Static Files with Shinylive How to deploy to GH pages etc. Share Shinylive: https://shiny.posit.co/py/docs/shinylive.html FIXME: this needs a visuals. Include relevant links: Code for deploying Shiny applications that will run completely in the browser, using Pyodide and webR (Python and R compiled to WebAssembly). https://ropensci.org/blog/2023/11/17/runiverse-wasm/ https://github.com/posit-dev/shinylive https://shinylive.io/r/examples/ and https://shinylive.io/py/examples/ Exporting ‘shiny’ applications with ‘shinylive’ allows you to run them entirely in a web browser, without the need for a separate R server. The traditional way of deploying ‘shiny’ applications involves in a separate server and client: the server runs R and ‘shiny’, and clients connect via the web browser. When an application is deployed with ‘shinylive’, R and ‘shiny’ run in the web browser (via ‘webR’): the browser is effectively both the client and server for the application. This allows for your ‘shiny’ application exported by ‘shinylive’ to be hosted by a static web server. – https://cran.r-project.org/web/packages/shinylive/index.html 7.16 Deploying Shiny Apps to Shinyapps.io Share your Shiny app as a web page synamic Shiny deployment (Shinyapps) static Shiny deployment (Shinylive + GH pages) IDE has button to deploy to Shinyapps, also show the rsconnect ways fr R &amp; Python The developers of Shiny have developed one-click solutions for deploying to ShinyApps.io. The caveat is that hosting costs can become quite costly, and there are limitations to the hours that an app can be run for in the free tier. To begin, sign up for ShinyApps.io. 7.16.1 R To deploy in RStudio, install the rsconnect package, load the rsconnect package. Shinyapps.io: free or paid cloud hosting with push-button publishing. Push-button publishing is available for Shinyapps.io from the RStudio IDE (desktop or server edition) or from any R console using the rsconnect R extension package. FIXME: add more here. 7.16.2 Python To deploy with Python, install the rsconnect-python pacakge, run the rsconnect commands in the command line. FIXME: add more here. "],["8-considerations-hosting.html", "Chapter 8 Considerations for Hosting Production Shiny Apps 8.1 Security 8.2 Performance, Availability, and Monitoring 8.3 Operations and Maintenance 8.4 Embedding Onto Your Website 8.5 OTHER STUFF", " Chapter 8 Considerations for Hosting Production Shiny Apps 8.1 Security 8.1.1 Certificates 8.1.2 Storing Secrets Environment variables Secrets service 8.1.3 Shiny App Authentication ShinyApps.io PositConnect ShinyProxy HTTP Basic Auth Reverse Proxy Built-in App 8.2 Performance, Availability, and Monitoring 8.2.1 Scaling 8.2.1.1 Benchmarking 8.2.1.2 What to Monitor CPU Memory Disk I/O Network traffic Uptime 8.3 Operations and Maintenance 8.3.1 CI/CD Alerts Updating Apps 8.4 Embedding Onto Your Website You may find yourself wanting to embed your app onto your existing website. Your existing website may be hosted elsewhere or run code that is independent of your Shiny app. In such cases, you may find using iframes useful. Iframe is an HTML tag that allows the embedding of websites within a website. Beware that iframes can be restricted by configuring your reverse proxy to send a header that most clients respect. X-Frame-Options: DENY 8.5 OTHER STUFF https://shiny.posit.co/r/articles/improve/scaling-and-tuning/ https://shiny.posit.co/r/articles/improve/scaling-and-tuning-ssp-rsc/ "],["9-information-about-hosting.html", "Chapter 9 Information about hosting", " Chapter 9 Information about hosting In most data-intensive situations, the capabilities of the backend system will determine your costs and the user experience. That is why it is important to make informed choices. data apps is scattered around the Internet and often incomplete. Recommendations are usually narrowly focused and never really ask the important questions. Such as: Why do you want this app deployed? Who is it for? What is your budget? The goal of this book is to help you learn about your hosting options. Depending on how you answer the questions you will be able to pick the option that suits your needs best. We have worked with clients from a variety of sectors, large and small, and advised about hosting data applications. Over the years, we have seen some patterns emerge, and we decided that it is time to share our experiences in the form of this website. Data applications are becoming more common. We have seen a shift from proof-of-concept and demo applications to business-critical dashboards and real-world decision support tools. Along with this trend, we also saw the diversification of client and user needs that requires the authors and developers of these data apps to constantly evaluate their hosting strategy. We have also noticed that clients want more control over their technology stack (branding, security, data regions) and costs. They are ready to invest in skill development to address their unique needs and to reduce the dependency on proprietary software/platform solutions. We will keep the Dev side of the cycle to a minimum on this website. There are truly great resources dedicated to general programming, data science, or app development, that we are not intending to repeat. Instead, we will provide relevant pointers for you to quickly find reliable information on these topics. This website focuses on the Ops side. We publish reviews to help in your decision-making process when it comes to hosting data apps. We also share step-by-step tutorials describing the various options from 1-click deployments to self-hosted clusters. This website is about hosting data apps. But what is a data app and why do you need hosting for it? "],["10-conclusions.html", "Chapter 10 Conclusions", " Chapter 10 Conclusions Conclusions &amp; next steps This is what you’ve learnt, and this is what you haven’t. Go here to find out more. "],["appendix-bananas.html", "The Bananas Data Set", " The Bananas Data Set The bananas data set is the product of a home experiment that one of the authors made during the first months of the COVID-19 pandemic. The data set tracks the ripening colour composition of banana fruits daily over 3 weeks period. The full data set can be found in the GitHub repository and R package bananas (install.packages(\"bananas\", repos = \"https://psolymos.r-universe.dev\")). The subset used in the book and the Shiny app constitutes the 6 fruits that were kept at room temperature. The table has the following fields: fruit: the identifier of the fruit, day: number between 0 and 20, the number of days since the first set of photographs, ripeness: the ripeness class of the fruit based in Peter’s personal judgement (Under, Ripe, Very, Over), green, yellow, brown: colour composition, these 3 values add up to 1 (100%). The colour composition was determined based on colour mapping the pixel values of the banana fruits and converting the pixel based 2-dimensional area to proportions. "],["appendix-lb-app.html", "Shiny App for Testing Load Balancing", " Shiny App for Testing Load Balancing Shiny apps can run multiple sessions in the same app instance. A common problem when scaling the number of replicas for shiny apps is that traffic might not be sent to the same session and thus the app might randomly fail. This app is used to determine if the HTTP requests made by the client are correctly routed back to the same R or Python process for the session. Both the Python and the R version of the app registers a dynamic route for the client to try to connect to. The JavaScript code on the client side will repeatedly hit the dynamic route. The server will send a 200 OK status code only if the client reached the correct Shiny session, where it originally came from. The original Python app was written by Joe Cheng and is from the rstudio/py-shiny GitHub repository1 FIXME: Where you can find it on the Book website. The Python Version Create a python folder. Put shiny in the requirements.txt file: shiny&gt;=0.2.7 Copy the app into the app.py file: from shiny import * import starlette.responses app_ui = ui.page_fluid( ui.markdown( &quot;&quot;&quot; ## Sticky load balancing test - Shiny for Python The purpose of this app is to determine if HTTP requests made by the client are correctly routed back to the same Python process where the session resides. It is only useful for testing deployments that load balance traffic across more than one Python process. If this test fails, it means that sticky load balancing is not working, and certain Shiny functionality (like file upload/download or server-side selectize) are likely to randomly fail. &quot;&quot;&quot; ), ui.tags.div( {&quot;class&quot;: &quot;card&quot;}, ui.tags.div( {&quot;class&quot;: &quot;card-body font-monospace&quot;}, ui.tags.div(&quot;Attempts: &quot;, ui.tags.span(&quot;0&quot;, id=&quot;count&quot;)), ui.tags.div(&quot;Status: &quot;, ui.tags.span(id=&quot;status&quot;)), ui.output_ui(&quot;out&quot;), ), ), ) def server(input: Inputs, output: Outputs, session: Session): @output @render.ui def out(): url = session.dynamic_route( &quot;test&quot;, lambda req: starlette.responses.PlainTextResponse( &quot;OK&quot;, headers={&quot;Cache-Control&quot;: &quot;no-cache&quot;} ), ) return ui.tags.script( f&quot;&quot;&quot; const url = &quot;{url}&quot;; const count_el = document.getElementById(&quot;count&quot;); const status_el = document.getElementById(&quot;status&quot;); let count = 0; async function check_url() {{ count_el.innerHTML = ++count; try {{ const resp = await fetch(url); if (!resp.ok) {{ status_el.innerHTML = &quot;Failure!&quot;; return; }} else {{ status_el.innerHTML = &quot;In progress&quot;; }} }} catch(e) {{ status_el.innerHTML = &quot;Failure!&quot;; return; }} if (count === 100) {{ status_el.innerHTML = &quot;Test complete&quot;; return; }} setTimeout(check_url, 10); }} check_url(); &quot;&quot;&quot; ) app = App(app_ui, server) Install the libraries with pip install -r requirements.txt. Run the app with shiny run --reload --port 8080 python/app.py, then visit http://127.0.0.1:8080 in your browser. You’ll see a counter running up to 100 and reporting if the test failed or succeeded. The R Version Create an r folder. Put the app code in the app.R file: library(shiny) library(bslib) ui &lt;- fixedPage( theme = bs_theme(version = 5), # force BS v5 markdown(&quot; ## Sticky load balancing test - Shiny for Python The purpose of this app is to determine if HTTP requests made by the client are correctly routed back to the same R process where the session resides. It is only useful for testing deployments that load balance traffic across more than one R process. If this test fails, it means that sticky load balancing is not working, and certain Shiny functionality (like file upload/download or server-side selectize) are likely to randomly fail. &quot;), tags$div( class = &quot;card&quot;, tags$div( class = &quot;card-body font-monospace&quot;, tags$div(&quot;Attempts: &quot;, tags$span(id=&quot;count&quot;, &quot;0&quot;)), tags$div(&quot;Status: &quot;, tags$span(id=&quot;status&quot;)), uiOutput(&quot;out&quot;) ) ) ) server &lt;- function(input, output, session) { url &lt;- session$registerDataObj( name = &quot;test&quot;, data = list(), filter = function(data, req) { message(&quot;INFO: &quot;, req$REMOTE_ADDR, &quot;:&quot;, req$REMOTE_PORT, &quot; - &quot;, req$REQUEST_METHOD, &quot; /session/&quot;, session$token, req$PATH_INFO, req$QUERY_STRING) shiny:::httpResponse( status = 200L, content_type = &quot;text/html; charset=UTF-8&quot;, content = &quot;OK&quot;, headers = list(&quot;Cache-Control&quot; = &quot;no-cache&quot;)) } ) output$out &lt;- renderUI({ message(&quot;Incoming connection&quot;) tags$script( sprintf(&#39; const url = &quot;%s&quot;; const count_el = document.getElementById(&quot;count&quot;); const status_el = document.getElementById(&quot;status&quot;); let count = 0; async function check_url() { count_el.innerHTML = ++count; try { const resp = await fetch(url); if (!resp.ok) { status_el.innerHTML = &quot;Failure!&quot;; return; } else { status_el.innerHTML = &quot;In progress&quot;; } } catch(e) { status_el.innerHTML = &quot;Failure!&quot;; return; } if (count === 100) { status_el.innerHTML = &quot;Test complete&quot;; return; } setTimeout(check_url, 10); } check_url(); &#39;, url) ) }) } app &lt;- shinyApp(ui, server) Install packages in R with install.packages(c(\"shiny\", \"bslib\")). Run the app in R with shiny::runApp(\"r\", port = 8080) then visit http://127.0.0.1:8080 in your browser. You’ll see a counter running up to 100 and reporting the success of the test. Shinylive Create Python shinylive version following https://github.com/posit-dev/py-shinylive (you will need to have shinylive installed): shinylive export python py-shinylive python3 -m http.server --directory py-shinylive 8008 Create R shinylive version following https://github.com/posit-dev/r-shinylive: R -q -e &#39;shinylive::export(&quot;r&quot;, &quot;r-shinylive&quot;)&#39; R -q -e &#39;httpuv::runStaticServer(&quot;r-shinylive&quot;, port=8008)&#39; Test Load Balancing The app is useful when the deployment includes load balancing between multiple replicas. For sush deployments, session affinity (or sticky sessions) needs to be available. This app can be used to test such setups. If the test fails, it will stop before the counter reaches 100 and will say Failure!. If the app succeeds 100 times, you’ll see Test complete. The app is not useful for testing a single instance deployment, or with Shinylive, because these setups won’t fail, try it! https://github.com/rstudio/py-shiny/blob/7ba8f90a44ee25f41aa8c258eceeba6807e0017a/examples/load_balance/app.py↩︎ "],["appendix-how-to-pick.html", "How to Pick the Right Hosting Option Start with the Why List Your Requirements Identify Your Constraints Options at a glance", " How to Pick the Right Hosting Option The Hosting Data Apps website recently celebrated its 6-months anniversary. During this time I have written 40 posts, almost all about Shiny hosting options. Some of these posts reviewed particular hosting options, such as Shinyapps.io, Shiny Server, Heroku, and ShinyProxy. A lot has been said about the hosting options themselves, but what about the needs of the developers and the users? The most important question to ask is: “which option is better for what**“? This is where developers and the users of the app come into the picture with their specific needs and constraints. You could say, for example, that “I want to host my portfolio for free and I don’t care about a custom domain name”. Or a nonprofit might say, “we want to host our apps at low cost, we want custom domains, and we want to be able to handle surge traffic, but we don’t want to maintain any servers”. These are really specific criteria, and if you ask me, I might say Shinyapps.io is best for you and Heroku with a Docker-based deployment is best for this organization. But how would you or I make such a decision? If you have been developing Shiny apps, you might already have your preferred way of deployment. But as your needs evolve, you will identify additional requirements and might find that your go-to option is not the best anymore. Then you’ll do some research and find the next option. If you are not yet familiar with Shiny hosting options, you still need to make an informed choice at some point, so that you are not wasting your time and effort on something that will not serve you well over the long run. Here is the 3 step process that you can follow to help you with this decision. Before you begin take a piece of paper. Start with the Why Why do you want the app or apps deployed? Are you building a portfolio to boost your career? Are you deploying useful apps for stakeholders or clients of your organization? Are you trying to sell an app as a software-as-a-service (SaaS) offering? Write down your answer. Getting clear on the why is the most important question. You might even realize that you don’t need to host your Shiny app. For example, your app might be used on a laptop as a GUI to analyze data by non-specialists in the field without internet or cell coverage. In this case, no need to move on to step 2, because all you need is to run Shiny locally. However, if your answer makes it clear to you that your users will be accessing the app over the Internet, move on to step 2. List Your Requirements Answering the Why question will probably reveal important details about your motivations, your audience, the number of apps you are going to host, etc. The answer will also bring you closer to identifying the requirements that you’ll need. For example, do you need a custom domain, how many users are you expecting, do you need authentication or app-level authorization? Do you want to host a single app or do you need to host many apps? Will you host non-Shiny apps? Write these down too. The following table lists the important features for many different Shiny hosting options. The table lists tiers offered by the same company as a separate option. Use this table to find the options that meet your requirements. For now, just ignore the columns inside the blue rectangle. If you crave a more interactive experience, I made a filterable version: View the video of it here: https://www.youtube.com/watch?v=iGKQMKuz-ww. Visit https://hosting.analythium.io/assets/files/shiny-hosting-options.html to filter the options and pick the right hosting option for your Shiny app. Once you filter the table according to your requirements, you’ll see a list of your ideal hosting options. Put these in the file or onto the paper too. Identify Your Constraints The last step involves identifying your constraints: What is your budget? What is your current skill level? How much time do you have time? Recognizing these constraints will guide you toward an optimal solution. This is the point where the columns inside the blue rectangle come in. The Total Cost of Ownership (TCO) (USD/year) covers licensing fees and operating costs for the “Number of Apps” listed in the table. Prices range quite a bit from free to the tens of thousands. Price increases with performance and with the availability of enterprise features, such as custom domains and authentication. PaaS means platform-as-a-service, i.e. it is a fully managed system without you having to worry about the underlying infrastructure. This also means less control over the infrastructure, i.e. when it comes to choosing the data region where your app is served from. Unlimited app hours are more common for self-hosted options or paid PaaS plans including a single app. The need to host multiple apps will involve some compromises. The ability to host non-Shiny apps (Dahs, Streamlit, etc.) is a feature for RStudio Connect and the Docker-based options (Shinyapps and Shiny Server can host Shiny for Python). Time as a constraint will depend on how far your current skill level is from the level needed for a specific hosting option. You also have to consider that some options are fully managed PaaS offerings, others you have to manage, or learn how to use Docker. If you have to develop new skills, it might take longer. If you have to manage your servers, it will take more time to get started and then you are on the hook for maintaining your setup. Make your selections inside the columns within the blue area. Options at a glance After the 3-step process, you should see only a few or a single option left. Click on the name of the hosting option and the link will take you to the relevant tag page on the Hosting Data Apps website: Follow the instructions in the tutorials to get started At the end of each post, you’ll find a Further reading section listing additional resources If there is no option left in the table, then you might need to be more realistic about your expectations or relax some of your constraints. For example, to keep costs low, you could spend more time and invest in skill development. But if you have more room in your budget, you might choose a different path. You can also revise your requirements until you find an acceptable solution. The following diagram gives an intuitive overview of the different options. The vertical axis represents the total cost from the table above: free, low, and high cost. The horizontal axis shows a range of skills you need to set up and manage your hosting solution. It can be as simple as pushing a button, or as complex as managing servers or cloud clusters. The hosting options in this diagram are not separated by tiers but rather shown as spanning over a range. The fill colours identify Docker and non-Docker-based options, the stroke styling indicates the PaaS solutions. Starting November 28, 2022, free Heroku Dynos, free Heroku Postgres, and free Heroku Data for Redis will no longer be available – see this FAQ for details. "],["appendix-setup.html", "Setting Up Your Development Environment", " Setting Up Your Development Environment Install R &amp; Python. Install Shiny. Install Shiny in R with install.packages(\"shiny\"), in Python with pip install shiny. RStudio VS Code https://shiny.posit.co/py/docs/install-create-run.html https://shiny.posit.co/r/getstarted/shiny-basics/lesson1/ R language support for VS Code, Python Shiny extension. Install Docker &amp; compose Get a shell VS Code RStudio terminal WSL term2 Other stuff we need? "],["references.html", "References", " References Aden-Buie, Garrick, Carson Sievert, Richard Iannone, JJ Allaire, and Barbara Borges. 2023. Flexdashboard: R Markdown Format for Flexible Dashboards. https://CRAN.R-project.org/package=flexdashboard. Allaire, JJ, Yihui Xie, Christophe Dervieux, Jonathan McPherson, Javier Luraschi, Kevin Ushey, Aron Atkins, et al. 2024. Rmarkdown: Dynamic Documents for r. https://github.com/rstudio/rmarkdown. Chang, Winston, Joe Cheng, JJ Allaire, Carson Sievert, Barret Schloerke, Yihui Xie, Jeff Allen, Jonathan McPherson, Alan Dipert, and Barbara Borges. 2024. Shiny: Web Application Framework for r. https://CRAN.R-project.org/package=shiny. Cheng, Joe, Winston Chang, Steve Reid, James Brown, Bob Trower, and Alexander Peslyak. 2024. Httpuv: HTTP and WebSocket Server Library. https://CRAN.R-project.org/package=httpuv. Coene, J. 2021. Javascript for r. Chapman &amp; Hall/CRC the r Series. CRC Press. https://books.google.ch/books?id=ntUxEAAAQBAJ. Coene, John. 2022. Leprechaun: Create Simple ’Shiny’ Applications as Packages. https://CRAN.R-project.org/package=leprechaun. Fay, Colin, Vincent Guyader, Sébastien Rochette, and Cervan Girard. 2023. Golem: A Framework for Robust Shiny Applications. https://CRAN.R-project.org/package=golem. Fay, Colin, Sébastien Rochette, Vincent Guyader, and Cervan Girard. 2021. Engineering Production-Grade Shiny Apps. Chapman &amp; Hall. https://engineering-shiny.org/. Gold, Alex. 2024. DevOps for Data Science. Chapman &amp; Hall. https://do4ds.com/. Granjon, David. 2022. Outstanding User Interfaces with Shiny. Chapman &amp; Hall. https://unleash-shiny.rinterface.com/. Hadley, Wickham, and Jennifer Bryan. 2023. R Packages. 2nd ed. O’Reilly Media, Inc. https://r-pkgs.org/. Hunter, J. D. 2007. “Matplotlib: A 2D Graphics Environment.” Computing in Science &amp; Engineering 9 (3): 90–95. https://doi.org/10.1109/MCSE.2007.55. Knuth, Donald. 1992. Literate Programming. Center for the Study of Language; Information—CSLI. Lai, Randy. 2023. Languageserver: Language Server Protocol. https://CRAN.R-project.org/package=languageserver. Leisch, Friedrich. 2002. “Sweave, Part i: Mixing r and LaTeX.” R News 2: 28–31. Meyer, David, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel, and Friedrich Leisch. 2023. E1071: Misc Functions of the Department of Statistics, Probability Theory Group (Formerly: E1071), TU Wien. https://CRAN.R-project.org/package=e1071. Pedregosa, F., G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, et al. 2011. “Scikit-Learn: Machine Learning in Python.” Journal of Machine Learning Research 12: 2825–30. R Core Team. 2024. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Rudolph, Konrad. 2024. Box: Write Reusable, Composable and Modular r Code. https://CRAN.R-project.org/package=box. Schloerke, Barret. 2024. Shinytest2: Testing for Shiny Applications. https://CRAN.R-project.org/package=shinytest2. Ushey, Kevin, JJ Allaire, and Yuan Tang. 2024. Reticulate: Interface to ’Python’. https://CRAN.R-project.org/package=reticulate. Waskom, Michael L. 2021. “Seaborn: Statistical Data Visualization.” Journal of Open Source Software 6 (60): 3021. https://doi.org/10.21105/joss.03021. Wickham, Hadley. 2021. Mastering Shiny. O’Reilly Media, Inc. https://mastering-shiny.org/. Wickham, Hadley, Peter Danenberg, Gábor Csárdi, and Manuel Eugster. 2024. Roxygen2: In-Line Documentation for r. https://CRAN.R-project.org/package=roxygen2. Xie, Yihui. 2024. Knitr: A General-Purpose Package for Dynamic Report Generation in r. https://yihui.org/knitr/. Żyła, Kamil, Jakub Nowicki, Leszek Siemiński, Marek Rogala, Recle Vibal, Tymoteusz Makowski, and Rodrigo Basa. 2024. Rhino: A Framework for Enterprise Shiny Applications. https://CRAN.R-project.org/package=rhino. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
