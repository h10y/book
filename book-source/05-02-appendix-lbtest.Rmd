# Shiny App for Testing Load Balancing {-#appendix-lb-app}

Shiny apps can run multiple sessions in the same app instance.
A common problem when scaling the number of replicas for shiny apps is that
traffic might not be sent to the same session and thus the app might randomly fail.

This app is used to determine if the HTTP requests made by the client are correctly 
routed back to the same R or Python process for the session.

Both the Python and the R version of the app registers a dynamic route for the client 
to try to connect to. The JavaScript code on the client side will repeatedly hit the
dynamic route. The server will send a 200 OK status code only if the client reached
the correct Shiny session, where it originally came from.

The original Python app was written by Joe Cheng and is from the `rstudio/py-shiny` GitHub repository[^Appendix-lb-app-01] 

[^Appendix-lb-app-01]: <https://github.com/rstudio/py-shiny/blob/7ba8f90a44ee25f41aa8c258eceeba6807e0017a/examples/load_balance/app.py>

FIXME: Where you can find it on the Book website.

### The Python Version {-}

Create a `python` folder.
Put `shiny` in the `requirements.txt` file:

```txt
shiny>=0.2.7
```

Copy the app into the `app.py` file:

```python
from shiny import *
import starlette.responses

app_ui = ui.page_fluid(
    ui.markdown(
        """
        ## Sticky load balancing test - Shiny for Python

        The purpose of this app is to determine if HTTP 
        requests made by the client are correctly routed 
        back to the same Python process where the session 
        resides. It is only useful for testing deployments 
        that load balance traffic across more than one 
        Python process.

        If this test fails, it means that sticky load 
        balancing is not working, and certain Shiny 
        functionality (like file upload/download or 
        server-side selectize) are likely to randomly fail.
        """
    ),
    ui.tags.div(
        {"class": "card"},
        ui.tags.div(
            {"class": "card-body font-monospace"},
            ui.tags.div("Attempts: ", ui.tags.span("0", id="count")),
            ui.tags.div("Status: ", ui.tags.span(id="status")),
            ui.output_ui("out"),
        ),
    ),
)

def server(input: Inputs, output: Outputs, session: Session):
    @output
    @render.ui
    def out():
        url = session.dynamic_route(
            "test",
            lambda req: starlette.responses.PlainTextResponse(
                "OK", headers={"Cache-Control": "no-cache"}
            ),
        )
        return ui.tags.script(
            f"""
            const url = "{url}";
            const count_el = document.getElementById("count");
            const status_el = document.getElementById("status");
            let count = 0;
            async function check_url() {{
                count_el.innerHTML = ++count;
                try {{
                    const resp = await fetch(url);
                    if (!resp.ok) {{
                        status_el.innerHTML = "Failure!";
                        return;
                    }} else {{
                        status_el.innerHTML = "In progress";
                    }}
                }} catch(e) {{
                    status_el.innerHTML = "Failure!";
                    return;
                }}
                if (count === 100) {{
                    status_el.innerHTML = "Test complete";
                    return;
                }}
                setTimeout(check_url, 10);
            }}
            check_url();
            """
        )

app = App(app_ui, server)
```

Install the libraries with `pip install -r requirements.txt`.
Run the app with `shiny run --reload --port 8080 python/app.py`,
then visit `http://127.0.0.1:8080` in your browser.
You'll see a counter running up to 100 and reporting if the test failed or succeeded.

### The R Version {-}

Create an `r` folder.
Put the app code in the `app.R` file:

```R
library(shiny)
library(bslib)

ui <- fixedPage(
    theme = bs_theme(version = 5), # force BS v5
    markdown("
## Sticky load balancing test - Shiny for Python

The purpose of this app is to determine if HTTP 
requests made by the client are correctly routed 
back to the same R process where the session 
resides. It is only useful for testing deployments 
that load balance traffic across more than one 
R process.

If this test fails, it means that sticky load 
balancing is not working, and certain Shiny 
functionality (like file upload/download or 
server-side selectize) are likely to randomly fail.
    "),
    tags$div(
        class = "card",
        tags$div(
            class = "card-body font-monospace",
            tags$div("Attempts: ", tags$span(id="count", "0")),
            tags$div("Status: ", tags$span(id="status")),
            uiOutput("out")
        )
    )
)

server <- function(input, output, session) {

    url <- session$registerDataObj(
        name   = "test",
        data   = list(),
        filter = function(data, req) {
            message("INFO: ",
                req$REMOTE_ADDR, ":",
                req$REMOTE_PORT,
                " - ",
                req$REQUEST_METHOD,
                " /session/",
                session$token,
                req$PATH_INFO,
                req$QUERY_STRING)
            shiny:::httpResponse(
                status = 200L,
                content_type = "text/html; charset=UTF-8",
                content = "OK",
                headers = list("Cache-Control" = "no-cache"))
        }
    )
    output$out <- renderUI({
        message("Incoming connection")
        tags$script(
            sprintf('
    const url = "%s";
    const count_el = document.getElementById("count");
    const status_el = document.getElementById("status");
    let count = 0;
    async function check_url() {
        count_el.innerHTML = ++count;
        try {
            const resp = await fetch(url);
            if (!resp.ok) {
                status_el.innerHTML = "Failure!";
                return;
            } else {
                status_el.innerHTML = "In progress";
            }
        } catch(e) {
            status_el.innerHTML = "Failure!";
            return;
        }
        if (count === 100) {
            status_el.innerHTML = "Test complete";
            return;
        }
        setTimeout(check_url, 10);
    }
    check_url();
            ', url)
        )
    })

}

app <- shinyApp(ui, server)
```

Install packages in R with `install.packages(c("shiny", "bslib"))`.
Run the app in R with `shiny::runApp("r", port = 8080)`
then visit `http://127.0.0.1:8080` in your browser.
You'll see a counter running up to 100 and reporting the success of the test.

### Shinylive {-}

Create Python shinylive version following <https://github.com/posit-dev/py-shinylive>
(you will need to have `shinylive` installed):

```bash
shinylive export python py-shinylive
python3 -m http.server --directory py-shinylive 8008
```

Create R shinylive version following <https://github.com/posit-dev/r-shinylive>:

```bash
R -q -e 'shinylive::export("r", "r-shinylive")'
R -q -e 'httpuv::runStaticServer("r-shinylive", port=8008)'
```

### Test Load Balancing {-}

The app is useful when the deployment includes load balancing between
multiple replicas. For sush deployments, session affinity (or sticky sessions) needs to 
be available. This app can be used to test such setups.

If the test fails, it will stop before the counter reaches 100 and will say _Failure!_.
If the app succeeds 100 times, you'll see _Test complete_.
The app is not useful for testing a single instance deployment, or with Shinylive,
because these setups won't fail, try it!
