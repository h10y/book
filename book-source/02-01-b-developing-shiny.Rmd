### Dynamic Documents

Dynamic documents stem from the _literate programming_ paradigm [@Knuth1992],
where natural language (like English) is interspersed with computer code snippets.
Nowadays, dynamic documents are used to create technical reports, slide decks
for presentations, and books, like the one you are reading.

Markdown is a common plain-text format for such dynamic documents, because it 
can be compiled into many different formats using [Pandoc](https://pandoc.org/).
R Markdown builds upon previous literate programming examples, e.g. Sweave
that mixes R and \LaTeX [@Leisch2002], and the flexibility provided by
Pandoc and the markdown format.

R Markdown contains chunks of embedded R (or other) code between opening 
and closing triple backticks. Underneath, you can find the 
`rmarkdown` [@R-rmarkdown] and `knitr` [@R-knitr] R packages at work.
A more recent iteration of this idea is [Quarto](https://quarto.org/).
Quarto is an open-source scientific and technical publishing system
that can include code chunks in many different formats frequently used by
data scientists (e.g. R, Python, Julia, Observable).

Both R Markdown and Quarto let you to use Shiny inside the documents
to build lightweight apps without worrying too much about a user interface.
Such interactive HTML documents cannot provide the same flexibility for
designing your apps as a standard Shiny app would, but it works wonders for
simpler use cases. Let's review how you can use Shiny in R Markdown (`.Rmd`)
and Quarto (`.qmd`) documents.

#### R Markdown

Markdown files usually begin with a _header_ that defines metadata for the 
document, like the title, the author, etc. The header is between
tripple dashes (`---`) and is written in YAML format (YAML stands for
YAML Ain't Markup Language).

We'd like to include the Old Faithful example in an R Markdown document.
So we create a file called `index.Rmd`.
In the YAML header we need to specify an output format that produces
HTML, e.g. `html_document`, and the runtime to be set to `shiny`:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ---',
'title: "Old Faithful"',
'output: html_document',
'runtime: shiny',
'---'), sep="\n    ")
```

The first code chunk would contain the data set definition and a `knitr` option 
to set the echo to false so we don't have to set it for every chunk:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{r include=FALSE}',
'knitr::opts_chunk$set(echo = FALSE)',
'x <- faithful$waiting',
'```'), sep="\n    ")
```

Next comes a code chunk with the slider widget:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{r}',
'sliderInput(',
'  inputId = "n",',
'  label = "Number of bins:",',
'  min = 1,',
'  max = 50,',
'  value = 25,',
'  ticks = TRUE',
')',
'```'), sep="\n    ")
```

Finally, we render the plot output:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{r}',
'renderPlot(',
'  alt = "Histogram of waiting times",',
'  {',
'    hist(',
'      x,',
'      breaks = seq(min(x), max(x), length.out = input$n + 1),',
'      freq = TRUE,',
'      col = "#BB74DB",',
'      border = "white",',
'      main = "Histogram of waiting times",',
'      xlab = "Waiting time to next eruption [mins]",',
'      ylab = "Frequency"',
'    )',
'    box()',
'  }',
')',
'```'), sep="\n    ")
```

FIXME: where can you find the full document.

The output format can be any format tha creates an HTML file. So for example,
you can use `ioslides_presentation` to create a slideshow with Shiny widgets
and interactivity. But because Shiny is involved, you need a server to run the 
document.

To render and run the document and the app inside it you can use
`rmarkdown::run("index.Rmd")`. As a result, the `rmarkdown` package will
extract the code chunks to create a server definition and uses the
`index.html` output file to stich in the reactive elements.

When you start the document, you will notice that it always renders the document
at startup. Not only that, but it also requires a full document render for each 
end user browser session when deployed.
This startup time for the users can be reduced if we render the HTML only once.
Running expensive data import and manipulation tasks only once would also greatly 
help the startup times. The runtime for this is called `shinyrmd` 
(or its alias, `shiny_prerendered`):

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ---',
'title: "Old Faithful"',
'output: flexdashboard::flex_dashboard',
'runtime: shinyrmd',
'---'), sep="\n    ")
```

We'll use the `flexdashboard` [@R-flexdashboard] package to give the document
more of a dashboard look and feel.

The execution of pre-rendered Shiny documents is divided into two 
execution contexts, the _rendering_ of the user interface and data,
and the _serving_ of the document to the users.

To indicate the rendering context, you can use `context="render"` chunk option,
but this can be omitted because this is the default context for all R code chunks.
The `"render"` is analogous of the `ui.R` file.
For the first chunk, we define `context="setup"` to mark code that 
is shared between the UI and the server. This is analogous to the `global.R`
file.

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{r context="setup",include=FALSE}',
'knitr::opts_chunk$set(echo = FALSE)',
'x <- faithful$waiting',
'```'), sep="\n    ")
```

We put the slider widget in the sidebar using the `"render"` context:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    Column {.sidebar}',
'-------------------------------------------------------------',
'',
'```{r context="render"}',
'sliderInput(',
'  inputId = "n",',
'  label = "Number of bins:",',
'  min = 1,',
'  max = 50,',
'  value = 25,',
'  ticks = TRUE',
')',
'```'), sep="\n    ")
```

The plot output element goes into the main panel, still as part of the `"render"` 
context:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    Column',
'-------------------------------------------------------------',
'',
'```{r context="render"}',
'plotOutput("histogram")',
'```'), sep="\n    ")
```

Finally, we define the `"server"` context for the reactive output.
This code is run when the interactive document is served and this is the 
same code that we would put into the `server.R` file:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{r context="server"}',
'output$histogram <- renderPlot(',
'  alt = "Histogram of waiting times",',
'  {',
'    hist(',
'      x,',
'      breaks = seq(min(x), max(x), length.out = input$n + 1),',
'      freq = TRUE,',
'      col = "#BB74DB",',
'      border = "white",',
'      main = "Histogram of waiting times",',
'      xlab = "Waiting time to next eruption [mins]",',
'      ylab = "Frequency"',
'    )',
'    box()',
'  }',
')',
'```'), sep="\n    ")
```

The `"render"` and `"server"` contexts are run in separate R sessions.
The first one is run when rendering happens, the second one is run many times,
once for each user. A consequence of this _context separation_ is that you cannot 
access variables created in "render" chunks within "server" chunks, and the 
other way around.

To render the document, we use `rmarkdown::render("index.Rmd")`,
then use `rmarkdown::run("index.Rmd")` to run the dashboard.
You can also set the `RMARKDOWN_RUN_PRERENDER` environment variable to `0`
to prevent any pre-rendering from happening, e.g. with 
`Sys.setenv(RMARKDOWN_RUN_PRERENDER=0)`.

You can include Python code chunks in your R Markdown documents. Python code is
evaluated using the `reticulate` package [@R-reticulate].
But you cannot include Shiny for Python in R Markdown. For that, you have Quarto.

#### Quarto with R

Quarto is very similar to R Markdown in many respects. You can think of it as a
generalized version of R Markdown that natively supports different programming
languages to run code chunks. You will find the YAML header familiar.
To use the Shiny runtime, we define `server: shiny`. The `format: html` is
means to produce HTML output. The `execute` part refers to global options,
so for `echo: false` means that example we don't want to code to be echoed into 
the document. Let's start with the following header information in a file 
called `index.qmd`:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ---',
'title: "Old Faithful"',
'execute:',
'  echo: false',
'format: html',
'server: shiny',
'---'), sep="\n    ")
```

The language is specified after the triple backticks, here `{r}` means R.
What is different from R Markdown is that chunk options are defined as
special comments prefaced with `#|` at the top of the code block
instead of following the language declaration inside the curly brackets.

UI elements belong to the render context, which is something we do not have
to specify:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{r}',
'plotOutput("histogram")',
'sliderInput(',
'  inputId = "n",',
'  label = "Number of bins:",',
'  min = 1,',
'  max = 50,',
'  value = 25,',
'  ticks = TRUE',
')',
'```'), sep="\n    ")
```

The `server-start` context will share code and data across multiple user sessions.
It will execute when the document is first run and will not re-execute for 
every new user. This is like our `global.R` file.

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{r}',
'#| context: server-start',
'x <- faithful$waiting',
'```'), sep="\n    ")
```

We can set the context to `server` for the next chunk:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{r}',
'#| context: server',
'output$histogram <- renderPlot(',
'  alt = "Histogram of waiting times",',
'  {',
'    hist(',
'      x,',
'      breaks = seq(min(x), max(x), length.out = input$n + 1),',
'      freq = TRUE,',
'      col = "#BB74DB",',
'      border = "white",',
'      main = "Histogram of waiting times",',
'      xlab = "Waiting time to next eruption [mins]",',
'      ylab = "Frequency"',
'    )',
'    box()',
'  }',
')',
'```'), sep="\n    ")
```

To render and serve this document we have to use the command
`quarto serve index.qmd`. Pre-rendering our document to speed up startup
times for the users is really straightforward. We do not have to change
the server type. We only have to first render the document with 
`quarto render index.qmd`. Then we can serve it with a flag that will tell
quarto not to render it again: `quarto serve index.qmd --no-render`.

If you wanted to split the `.qmd` file into multiple files corresponding to
the evaluation contexts, you can have the header and the UI definition in
the `index.qmd` file. Put the code for the `server-start` context into the
`global.R` file. The `server.R` file should return the server function:

```R
# server.R
function(input, output, session) {
  output$histogram <- renderPlot(
    alt = "Histogram of waiting times",
    {
      hist(
        x,
        breaks = seq(min(x), max(x), length.out = input$n + 1),
        freq = TRUE,
        col = "#BB74DB",
        border = "white",
        main = "Histogram of waiting times",
        xlab = "Waiting time to next eruption [mins]",
        ylab = "Frequency"
      )
      box()
    }
  )
}
```

#### Quarto with Python

The Python version or our Quarto-based Shiny app is very similar to the R version.
No change is headed in the header. The code chunks will have `{python}`
defined instead of `{r}`, and of course you have to copy the Python code
inside the chunks.

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ---',
'title: "Old Faithful"',
'execute:',
'  echo: false',
'format: html',
'server: shiny',
'---'), sep="\n    ")
```

The next chunk contains the setup and loads libraries:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{python}',
'import seaborn as sns',
'import matplotlib.pyplot as plt',
'from shiny import App, render, ui',
'',
'faithful = sns.load_dataset("geyser")',
'x = faithful.waiting',
'```'), sep="\n    ")
```

The UI elements, like the slider input control, come next:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{python}',
'ui.input_slider(',
'        id="n",',
'        label="Number of bins:",',
'        min=1,',
'        max=50,',
'        value=25,',
'        ticks=True)',
'```'), sep="\n    ")
```

Finally, the rendered plot:

```{r eval=TRUE,echo=FALSE,results="asis"}
cat(c('    ```{python}',
'@render.plot(alt="Histogram of waiting times")',
'def histogram():',
'    plt.hist(',
'        x,',
'        bins = input.n(),', 
'        density=False, ',
'        color="#BB74DB",',
'        edgecolor="white")',
'    plt.title("Histogram of waiting times")',
'    plt.xlabel("Waiting time to next eruption [mins]")',
'    plt.ylabel("Frequency")',
'```'), sep="\n    ")
```

Rendering and serving the Python document is the same you used for the R version:
`quarto serve index.qmd` will do both, so for a pre rendered version, use
`quarto render index.qmd` first and the serve with the `--no-render` flag.

### Shinylive

Using [Shinylive](https://shiny.posit.co/py/docs/shinylive.html), you can run 
Shiny applications entirely in a web browser, i.e. on the client side, without 
the need for a separate server running in R or Python. This is achieved by 
R or Python running in the browser. The Python implementation of Shinylive uses 
[WebAssembly (WASM)](https://webassembly.org/) and [Pyodide](https://pyodide.org/). 
WASM is a binary format for compiled programs that can run in a web browser, 
whereas Pyodide is a port of Python and many Python packages compiled to WASM.

#### Python Shinylive

We will create Python Shinylive version of the _Hello Shiny_ app following 
the [`posit-dev/py-shinylive`](https://github.com/posit-dev/py-shinylive) GitHub repository.
First, export the app inside the `py-shiny` folder with the single-file app
and put the Shinylive version in the `py-shinylive` folder:

```bash
shinylive export python py-shinylive
```

The Shiny live version will consist of _static_ files, which means that we can 
copy these files to any static hosting site (like Netlify or GitHub Pages), 
and a browser will be able to display the contents irrespective of the 
underlying operating system, and without the need to have a Python available.

Can we view the output locally? If you click on the `index.html` sitting
in the `py-shinylive` folder, you will most likely get an error in the browser.
To read the error you have to find the _developer tools_ and check the
error messages. You will see something like this:

```text
Cross-Origin Request Blocked: The Same Origin Policy disallows reading 
the remote resource at file:///[...]/shinylive/shinylive.js. 
(Reason: CORS request not http).
```

For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts.
But what is this cross-origin resource sharing ([CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS))?
If you load the HTML file (like our `index.html`) from a source, the default CORS
behaviour will expect any other files, like images, or JavaScript/CSS scripts
to have the same _origin_. By origin, we mean the domain and subdomain.

Now the problem here is that you are viewing a local version of the files,
which will set the protocol part of the URIs to be `file://` instead of
`http://` as indicated in the message. Although the folder following the
file protocol is the same, but this is considered as having opaque origins
by most browsers and therefore will be disallowed.

If you want to view the files locally, you do it through a local server. 
That way, all files are served from the same scheme and domain (`localhost`) 
and have the same origin.
Start the server as:

```bash
python3 -m http.server --directory py-shinylive
```

Now visit `http://localhost:8000/` in your browser, and the CORS error should
be gone (port 8000 is the default port for `http.server`).

#### R Shinylive

Shinylive for R uses similar technology built on WebAssembly using the 
[WebR](https://docs.r-wasm.org/webr/latest/) R package.
Here is how to create an R Shinylive version of the _Hello Shiny_ app 
following the [`posit-dev/r-shinylive`](https://github.com/posit-dev/r-shinylive/) 
GitHub repository using the interactive R console:

```R
shinylive::export("r", "r-shinylive")
httpuv::runStaticServer("r-shinylive")
```

The first line compiles the Shiny app that is inside the `r-shiny` folder into 
the Shinylive version in the `r-shinylive` folder.
The second command will start the server and open the page in the browser.
You will see a random port used on localhost, e.g. `http://127.0.0.1:7446`.

#### Shinylive in Quarto

We can include Shinylive (R or Python) apps in Quarto. For that, we need to
install the [Shinylive quarto extension](https://github.com/quarto-ext/shinylive) 
inside the Quarto project folder with `quarto add quarto-ext/shinylive`.

The header of the Quarto document should list the `shinylive` extension under 
`filter`:

    ---
    title: "Old Faithful"
    format: html
    filters:
      - shinylive
    ---

You can include the Shiny application code into a code chunk marked with 
`{shinylive-r}` or `{shinylive-python}`. Use the comment `standalone: true`
which tells Quarto that the block contains a complete Shiny app, and not
only parts of it, as we saw before.
For R, we include the full single-file app. The `viewerHeight: 500` comment is
needed to have enough space for the UI:

    ```{shinylive-r}
    #| standalone: true
    #| viewerHeight: 500

    [...]
    ```

The Python version uses `{shinylive-python}` and the Python version of the
single-file Old Faithful Shiny app:

    ```{shinylive-python}
    #| standalone: true
    #| viewerHeight: 500

    [...]
    ```

To view the Quarto document in your browser, use `quarto preview index.qmd`. 
This will work with the R and the Python versions alike.
